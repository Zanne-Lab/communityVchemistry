---
title: "Does endophyte composition explain decay?"
author: "Marissa Lee"
date: "12/2/2018"
output: github_document
---

Contents:
1. CODE-S1. Test role of endophyte composition. Exclude C fraction data, include small stems.
2. CODE-S2. Test role of endophyte composition. C fraction data
3. STEM-S1. Test role of endophyte composition. Exclude C fraction data, include small stems.
4. STEM-S2. Test role of endophyte composition. C fraction data

1-r. CODE-S1. Test role of endophyte composition after accounting for traits. Exclude C fraction data, include small stems.
2-r. CODE-S2. Test role of endophyte composition after accounting for traits. C fraction data.
3-r. STEM-S1. Test role of endophyte composition after accounting for traits. Exclude C fraction data, include small stems.
4-r. STEM-S2. Test role of endophyte composition after accounting for traits. C fraction data.

___________________
___________________

Load libraries and functions
```{r}
#chunk options
knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)

#---------------------------#
#libraries
library(tidyverse) # ggplot2, dplyr, tidyr, readr, purrr
library(easystats) # report, performance, parameters, correlation, effectsize
library(rioja) # for WAPLS

# commented out because I'm going to try using easystats instead...
#library(tidymodels) # broom
#library(sjstats) #provides function eta_sq() to extract r2 for each predictor in a lm
#library(lmtest) # for coxtest()

# commented out because I'm going to try using cowplot instead
#library(grid) #plotting
#library(gridExtra) # plotting
#library(GGally) # bivariate plots



#---------------------------#
#fxns
source('code/helper_fxns.R')
sourceDir('code')

```

Load OTU tables
```{r}
otu.list <- readRDS(file = "derived_data/otu_list.RData")
otu.list.trimmed <- readRDS(file = "derived_data/otu_list_trimmed.RData")
```

Load decay data
```{r loaddata}

# samples and decay
stemSamples <- load_stemSamples() # this function is in load_microbeData.R
initial_mass <- read_in_initial_mass()
harvest_mass <- LoadHarvestFiles()
pmr <- Calc_massRemaining(initial_mass, harvest_mass) # calculate percent mass remaining (pmr)
pmr_byStem <- AvgPMR_byStem(pmr, long.form = F) # average pmr for each stem and timepoint
stem.respVars <- list("time7", "time13", "time25", "time37","time59")
decayfits <- read_csv("derived_data/decayfits.csv") # see 1_decayPatterns.Rmd to update
code.respVars <- list("w.t50","beta","alpha","w.r2")
# weibull params
# beta = scale param = higher values mean *slower* decay
# alpha = shape param = higher values mean more S-shaped
```

Load residuals from 2b_woodTraits_explainDecay.Rmd
```{r}
resids_explainDecay.list <- readRDS(file = "derived_data/resids_explainDecay_list.RData")

```

___________________
# 1. CODE-S1. Test role of endophyte composition. Exclude C fraction data, include small stems.

calculate code-level OTU abundances
```{r}
# stemSamples
# comm.otu <- otu.list$all
# slice <- 1
# 
# seqSamples <- load_seqSamples(mat.otu = comm.otu, stemSamples)
# codeOTUabund <- AverageOTUabund_byCode(comm.otu=comm.otu, seqSamples=seqSamples) 
# #remove eusc because there is no community data for this code
# codeOTUabund <- codeOTUabund[row.names(codeOTUabund) != "eusc",]
# write.csv(codeOTUabund, file="derived_data/codeOTUabund.csv")
```

set up dataframe (otu table and response matrix)
```{r}
codeOTUabund <- read.csv(file="derived_data/codeOTUabund.csv",
                         stringsAsFactors = F, row.names = 1)
dim(codeOTUabund) # all OTUs
setup_wapls_data <- function(codeOTUabund, comm.otu, stemSamples, resp.mat, slice){
  
  # subset OTUs based on current comm.otu
  curr.codeOTUabund <- codeOTUabund[,colnames(codeOTUabund) %in% colnames(comm.otu)]
  
  # subset samples by size based on data slice
  if(slice == 2){
    seqSamples <- load_seqSamples(mat.otu = comm.otu, stemSamples)
    size.indx <- unique(seqSamples[,c("code","size")])
    df <- data.frame(code = row.names(curr.codeOTUabund))
    df %>%
      left_join(size.indx) %>%
      filter(size == "large") -> df
    curr.codeOTUabund <- curr.codeOTUabund[row.names(curr.codeOTUabund) %in% df$code,]
    dim(curr.codeOTUabund)
  }
  
  # remove empty samples (no OTUs present)
  dim(curr.codeOTUabund)
  n.emptyrows <- sum(rowSums(curr.codeOTUabund) == 0)
  if(n.emptyrows != 0){
    curr.codeOTUabund <- curr.codeOTUabund[rowSums(curr.codeOTUabund) != 0,]
  }
  
  # remove empty OTUs (not present in any sample)
  dim(curr.codeOTUabund)
  n.emptycols <- sum(colSums(curr.codeOTUabund) == 0)
  if(n.emptycols != 0){
    curr.codeOTUabund <- curr.codeOTUabund[,colSums(curr.codeOTUabund) != 0]
  }
  
  # subset decayfits and order based on otu matrix
  df <- data.frame(code = row.names(curr.codeOTUabund))
  df %>%
    left_join(resp.mat) -> curr.respmat
  df
  data <- list(otu = curr.codeOTUabund, resp = curr.respmat)

  return(data)
  
}

otu.list %>%
  map(~setup_wapls_data(codeOTUabund, comm.otu = .x, stemSamples, resp.mat = decayfits, slice = 1)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
code.respVars

k.list <- list()
i.list <- list()
names(waplsdata.list)
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(code.respVars)){
    # select current response variable
    respvar <- code.respVars[[k]]
 
    #fit models and test signif
    dim(tmp$otu)
    fit <- WAPLS(y=tmp$otu, x=tmp$resp[[respvar]], npls=2)
    fit.cv<-crossval(fit, cv.method="loo")
    mod.out <-rand.t.test(fit.cv) 
    print(i); print(k); print(mod.out)
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(tmp$otu)[2], 
                               n.samples = dim(tmp$otu)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(tmp$otu)[2], n.samples = dim(tmp$otu)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_C1.txt", append = T)
  }
  names(k.list) <- unlist(code.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "C1"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_C1.csv")

```
None of the components are significant.


___________________
# 2. CODE-S2. Test role of endophyte composition. C fraction data, exclude small stems.

calculate code-level OTU abundances
```{r}
codeOTUabund <- read.csv(file="derived_data/codeOTUabund.csv", 
                         row.names = 1,
                         stringsAsFactors = F)
```

set up dataframe (otu table and response matrix)
```{r}
otu.list %>%
  map(~setup_wapls_data(codeOTUabund, comm.otu = .x, stemSamples, resp.mat = decayfits, slice = 2)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
code.respVars

names(waplsdata.list)
k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  for(k in 1:length(code.respVars)){
    # select current response variable
    respvar <- code.respVars[[k]]
    
    #fit models and test signif
    if(dim(tmp$otu)[1] < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=tmp$otu, x=tmp$resp[[respvar]], npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k)
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(tmp$otu)[2], 
                               n.samples = dim(tmp$otu)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(tmp$otu)[2], n.samples = dim(tmp$otu)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_C2.txt", append = T)
  }
  names(k.list) <- unlist(code.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "C2"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_C2.csv")

```
None of the components are significant.

___________________
# 3. STEM-S1. Test role of endophyte composition. Exclude C fraction data

set up dataframe (otu table and response matrix)
```{r}
# comm.otu <- otu.list$all
# resp.mat <- pmr_byStem
# slice <- 2

setup_wapls_data_stem <- function(comm.otu, stemSamples, resp.mat, slice){
  
  
  # subset samples by size based on data slice
  if(slice == 2){
    seqSamples <- load_seqSamples(mat.otu = comm.otu, stemSamples)
    seqSamples %>%
      filter(size == "large") -> seqSamples.large
    curr.comm.otu <- comm.otu[row.names(comm.otu) %in% seqSamples.large$seq_sampName,]
    dim(curr.comm.otu)
  }else{
    curr.comm.otu <- comm.otu
  }
  
  # remove empty samples (no OTUs present)
  dim(curr.comm.otu)
  n.emptyrows <- sum(rowSums(curr.comm.otu) == 0)
  n.emptyrows
  if(n.emptyrows != 0){
    curr.comm.otu <- curr.comm.otu[rowSums(curr.comm.otu) != 0,]
  }
  
  # remove empty OTUs (not present in any sample)
  dim(curr.comm.otu)
  n.emptycols <- sum(colSums(curr.comm.otu) == 0)
  n.emptycols
  if(n.emptycols != 0){
    curr.comm.otu <- curr.comm.otu[,colSums(curr.comm.otu) != 0]
  }
  
  # subset resp.mat and order based on otu matrix
  df <- data.frame(codeStem = row.names(curr.comm.otu))
  head(resp.mat)
  df %>%
    left_join(resp.mat) -> curr.respmat
  data <- list(otu = curr.comm.otu, resp = curr.respmat)
  
  return(data)
  
}

otu.list %>%
  map(~setup_wapls_data_stem(comm.otu = .x, stemSamples, resp.mat = pmr_byStem, slice = 1)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))
# be careful! this still has NAs in the response matrix... will need to deal with this below

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
stem.respVars

k.list <- list()
i.list <- list()
names(waplsdata.list)
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(stem.respVars)){
    # select current response variable
    respvar <- stem.respVars[[k]]
    respvar
    # remove NAs from respvar dataset
    selection <- !is.na(tmp$resp[[respvar]])
    y <- tmp$otu[selection,]
    x <- tmp$resp[[respvar]][!is.na(tmp$resp[[respvar]])]
    dim(y)
    length(x)
    
    # check again for empty cols
    n.emptycols <- sum(colSums(y) == 0)
    if(n.emptycols != 0){
      new.y <- y[,colSums(y)!=0]
      y <- new.y
    }
    print(dim(y))
    
    #fit models and test signif
    if(length(x) < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=y, x=x, npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k)
    
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(y)[2], 
                               n.samples = dim(y)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(y)[2], n.samples = dim(y)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_S1.txt", append = T)
  }
  names(k.list) <- unlist(stem.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "S1"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_S1.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
Only 1 component is significant -- Full community at time = 37


___________________
# 4. STEM-S2. Test role of endophyte composition. C fraction data

set up dataframe (otu table and response matrix)
```{r}
#comm.otu <- otu.list$all
#resp.mat <- pmr_byStem

otu.list %>%
  map(~setup_wapls_data_stem(comm.otu = .x, 
                             stemSamples, 
                             resp.mat = pmr_byStem, 
                             slice = 2)) -> waplsdata.list


waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))
# # be careful! this still has NAs in the response matrix... will need to deal with this below

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
stem.respVars
names(waplsdata.list)

k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(stem.respVars)){
    # select current response variable
    respvar <- stem.respVars[[k]]
    respvar
    # remove NAs from respvar dataset
    selection <- !is.na(tmp$resp[[respvar]])
    y <- tmp$otu[selection,]
    x <- tmp$resp[[respvar]][!is.na(tmp$resp[[respvar]])]
    dim(y)
    length(x)
    # check again for empty cols
    n.emptycols <- sum(colSums(y) == 0)
    n.emptycols
    if(n.emptycols != 0){
      new.y <- y[,colSums(y)!=0]
      y <- new.y
    }
    print(dim(y))
    
    #fit models and test signif
    length(x)
    if(length(x) < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=y, x=x, npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k)
    
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(y)[2], 
                               n.samples = dim(y)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(y)[2], n.samples = dim(y)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_S2.txt", append = T)
  }
  names(k.list) <- unlist(stem.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "S2"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_S2.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
2 things are significant: Basidios at time25 and Pathotrophs at time59


___________________
# 1-r. CODE-S1. Test role of endophyte composition after accounting for traits. Exclude C fraction data, include small stems.

set up dataframe (otu table and response matrix)
```{r}
codeOTUabund <- read.csv(file="derived_data/codeOTUabund.csv",
                         stringsAsFactors = F, row.names = 1)
#codeOTUabund # all OTUs

setup_wapls_data <- function(codeOTUabund, comm.otu, stemSamples, resp.mat, slice){
  
  # subset OTUs based on current comm.otu
  curr.codeOTUabund <- codeOTUabund[,colnames(codeOTUabund) %in% colnames(comm.otu)]
  
  # subset samples by size based on data slice
  if(slice == 2){
    seqSamples <- load_seqSamples(mat.otu = comm.otu, stemSamples)
    size.indx <- unique(seqSamples[,c("code","size")])
    df <- data.frame(code = row.names(curr.codeOTUabund))
    df %>%
      left_join(size.indx) %>%
      filter(size == "large") -> df
    curr.codeOTUabund <- curr.codeOTUabund[row.names(curr.codeOTUabund) %in% df$code,]
    dim(curr.codeOTUabund)
  }
  
  # remove empty samples (no OTUs present)
  dim(curr.codeOTUabund)
  n.emptyrows <- sum(rowSums(curr.codeOTUabund) == 0)
  if(n.emptyrows != 0){
    curr.codeOTUabund <- curr.codeOTUabund[rowSums(curr.codeOTUabund) != 0,]
  }
  
  # remove empty OTUs (not present in any sample)
  dim(curr.codeOTUabund)
  n.emptycols <- sum(colSums(curr.codeOTUabund) == 0)
  if(n.emptycols != 0){
    curr.codeOTUabund <- curr.codeOTUabund[,colSums(curr.codeOTUabund) != 0]
  }
  
  # subset decayfits and order based on otu matrix
  df <- data.frame(code = row.names(curr.codeOTUabund))
  df %>%
    left_join(resp.mat) -> curr.respmat
  df
  data <- list(otu = curr.codeOTUabund, resp = curr.respmat)

  return(data)
  
}

# load residuals
resids_explainDecay.list <- readRDS(file = "derived_data/resids_explainDecay_list.RData")
residfits.c1<- resids_explainDecay.list[['C1']]
residfits.c1 %>%
  spread(key = resp, value = resid) -> residfits.c1.w
otu.list %>%
  map(~setup_wapls_data(codeOTUabund, comm.otu = .x, stemSamples, 
                        resp.mat = residfits.c1.w, slice = 1)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
code.respVars

names(waplsdata.list)
k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(code.respVars)){
    # select current response variable
    respvar <- code.respVars[[k]]
 
    #fit models and test signif
    dim(tmp$otu)
    tmp$otu
    tmp$resp[[respvar]]
    fit <- WAPLS(y=tmp$otu, x=tmp$resp[[respvar]], npls=2)
    fit.cv<-crossval(fit, cv.method="loo")
    mod.out <-rand.t.test(fit.cv) 
    print(i); print(k); print(mod.out)
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(tmp$otu)[2], 
                               n.samples = dim(tmp$otu)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(tmp$otu)[2], n.samples = dim(tmp$otu)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }
    #capture.output(mod.out.df, file = "output/tables/wapls_C1_resids.txt", append = T)
    k.list[[k]] <- mod.out.df
  }
  names(k.list) <- unlist(code.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "C1_resid"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_C1_resid.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
None of the components are significant.


___________________
# 2-r. CODE-S2. Test role of endophyte composition after accounting for traits. C fraction data.

set up dataframe (otu table and response matrix)
```{r}
codeOTUabund <- read.csv(file="derived_data/codeOTUabund.csv",
                         stringsAsFactors = F, row.names = 1)
#codeOTUabund # all OTUs

# load residuals
resids_explainDecay.list <- readRDS(file = "derived_data/resids_explainDecay_list.RData")
residfits.c2<- resids_explainDecay.list[['C2']]
residfits.c2 %>%
  spread(key = resp, value = resid) -> residfits.c2.w
otu.list %>%
  map(~setup_wapls_data(codeOTUabund, comm.otu = .x, stemSamples, 
                        resp.mat = residfits.c2.w, slice = 2)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
code.respVars

names(waplsdata.list)
k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(code.respVars)){
    # select current response variable
    respvar <- code.respVars[[k]]
 
    #fit models and test signif
    dim(tmp$otu)
    tmp$otu
    x<-tmp$resp[[respvar]]
    if(length(x) < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=tmp$otu, x=tmp$resp[[respvar]], npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k); print(mod.out)
    
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(tmp$otu)[2], 
                               n.samples = dim(tmp$otu)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(tmp$otu)[2], n.samples = dim(tmp$otu)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- code.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_C2_resids.txt", append = T)
  }
  names(k.list) <- unlist(code.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "C2_resid"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_C2_resid.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
None of the components are significant.


___________________
# 3-r. STEM-S1. Test role of endophyte composition after accounting for traits. Exclude C fraction data, include small stems.

set up dataframe (otu table and response matrix)
```{r}

setup_wapls_data_stem <- function(comm.otu, stemSamples, resp.mat, slice){
  
  
  # subset samples by size based on data slice
  if(slice == 2){
    seqSamples <- load_seqSamples(mat.otu = comm.otu, stemSamples)
    seqSamples %>%
      filter(size == "large") -> seqSamples.large
    curr.comm.otu <- comm.otu[row.names(comm.otu) %in% seqSamples.large$seq_sampName,]
    dim(curr.comm.otu)
  }else{
    curr.comm.otu <- comm.otu
  }
  
  # remove empty samples (no OTUs present)
  dim(curr.comm.otu)
  n.emptyrows <- sum(rowSums(curr.comm.otu) == 0)
  n.emptyrows
  if(n.emptyrows != 0){
    curr.comm.otu <- curr.comm.otu[rowSums(curr.comm.otu) != 0,]
  }
  
  # remove empty OTUs (not present in any sample)
  dim(curr.comm.otu)
  n.emptycols <- sum(colSums(curr.comm.otu) == 0)
  n.emptycols
  if(n.emptycols != 0){
    curr.comm.otu <- curr.comm.otu[,colSums(curr.comm.otu) != 0]
  }
  
  # subset resp.mat and order based on otu matrix
  df <- data.frame(codeStem = row.names(curr.comm.otu))
  head(resp.mat)
  df %>%
    left_join(resp.mat) -> curr.respmat
  data <- list(otu = curr.comm.otu, resp = curr.respmat)
  
  return(data)
  
}

# load residuals
resids_explainDecay.list <- readRDS(file = "derived_data/resids_explainDecay_list.RData")
residfits.s1<- resids_explainDecay.list[['S1']]
residfits.s1 %>%
  spread(key = resp, value = resid) -> residfits.s1.w
otu.list %>%
  map(~setup_wapls_data_stem(comm.otu = .x, stemSamples, 
                             resp.mat = residfits.s1.w, slice = 1)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))
# be careful! this still has NAs in the response matrix... will need to deal with this below


```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
stem.respVars

names(waplsdata.list)
k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(stem.respVars)){
    # select current response variable
    respvar <- stem.respVars[[k]]
    respvar
    # remove NAs from respvar dataset
    selection <- !is.na(tmp$resp[[respvar]])
    y <- tmp$otu[selection,]
    x <- tmp$resp[[respvar]][!is.na(tmp$resp[[respvar]])]
    dim(y)
    length(x)
    
    # check again for empty cols
    n.emptycols <- sum(colSums(y) == 0)
    if(n.emptycols != 0){
      new.y <- y[,colSums(y)!=0]
      y <- new.y
    }
    print(dim(y))
    
    #fit models and test signif
    if(length(x) < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=y, x=x, npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k); print(mod.out)
    
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(y)[2], 
                               n.samples = dim(y)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(y)[2], n.samples = dim(y)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_S1_resids.txt", append = T)
  }
  names(k.list) <- unlist(stem.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "S1_resid"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_S1_resid.csv")
#tibtab.sum <- read.csv(file = "output/tables/wapls_S1_resid.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
None are significant

plot marginally significant relationship between all endos and pmr time37
```{r}

waplsdata.list

# select current response variable
otu.tmp <- waplsdata.list$all$otu
resp.tmp <- waplsdata.list$all$resp

# remove NAs from respvar dataset
selection <- !is.na(resp.tmp$time37)
y <- otu.tmp[selection,]
x <- resp.tmp$time37[selection]

# check again for empty cols
n.emptycols <- sum(colSums(y) == 0)
n.emptycols  
if(n.emptycols != 0){
      new.y <- y[,colSums(y)!=0]
      y <- new.y
    }
dim(y)
fit <- WAPLS(y=y, x=x, npls=2)

comp1.df <- data.frame(codeStem = row.names(fit$T), fit$T,
                    row.names = NULL)
comp1.df %>%
  left_join(resp.tmp) %>%
  select(codeStem, Comp01, time37) -> comp1.df

ggplot(comp1.df, aes(x = Comp01, y = time37)) +
  geom_point() +
  ylab("Percent mass remaining after 3 yrs") +
  xlab("Endophyte WA-PLS Component 1")

# add trait data
traits.stem <- read.csv(file = "derived_data/traits_stem.csv", row.names = 1)
head(traits.stem)
comp1.df %>%
  left_join(traits.stem) -> comp1.df

colnames(comp1.df)
ggplot(comp1.df, aes(x = Comp01, y = Ca, shape = size)) +
  geom_point() +
  ylab("Wood water content") +
  xlab("Endophyte WA-PLS Component 1")

ggplot(comp1.df, aes(x = Comp01, y = time37, shape = size)) +
  geom_point() +
  ylab("Percent mass remaining after 3 yrs") +
  xlab("Endophyte WA-PLS Component 1")

ggplot(comp1.df, aes(y = time37, x = waterperc, shape = size)) +
  geom_point() +
  xlab("Wood water content") +
  ylab("Percent mass remaining after 3 yrs")



```

___________________
# 4-r. STEM-S2. Test role of endophyte composition after accounting for traits. C fraction data.


set up dataframe (otu table and response matrix)
```{r}

# load residuals
resids_explainDecay.list <- readRDS(file = "derived_data/resids_explainDecay_list.RData")
residfits.s2<- resids_explainDecay.list[['S2']]
residfits.s2 %>%
  spread(key = resp, value = resid) -> residfits.s2.w
otu.list %>%
  map(~setup_wapls_data_stem(comm.otu = .x, stemSamples, 
                             resp.mat = residfits.s2.w, slice = 2)) -> waplsdata.list

waplsdata.list %>%
  map(~dim(.x$resp))
waplsdata.list %>%
  map(~dim(.x$otu))
# be careful! this still has NAs in the response matrix... will need to deal with this below

```

fit wapls
```{r, message = F, results = F}

require(rioja) # for WAPLS
stem.respVars

names(waplsdata.list)
k.list <- list()
i.list <- list()
for(i in 1:length(waplsdata.list)){
  # select current community type
  tmp <- waplsdata.list[[i]]
  
  for(k in 1:length(stem.respVars)){
    # select current response variable
    respvar <- stem.respVars[[k]]
    respvar
    # remove NAs from respvar dataset
    selection <- !is.na(tmp$resp[[respvar]])
    y <- tmp$otu[selection,]
    x <- tmp$resp[[respvar]][!is.na(tmp$resp[[respvar]])]
    dim(y)
    length(x)
    
    # check again for empty cols
    n.emptycols <- sum(colSums(y) == 0)
    if(n.emptycols != 0){
      new.y <- y[,colSums(y)!=0]
      y <- new.y
    }
    print(dim(y))
    
    #fit models and test signif
    if(length(x) < 5){
      mod.out <-NA
    }else{
      fit <- WAPLS(y=y, x=x, npls=2)
      fit.cv<-crossval(fit, cv.method="loo")
      mod.out <-rand.t.test(fit.cv) 
    }
    print(i); print(k); print(mod.out)
    
    if(is.na(mod.out)){
      mod.out.df <- data.frame(result = "too few samples",
                               n.asvs = dim(y)[2], 
                               n.samples = dim(y)[1])
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }else{
      mod.out.df <- data.frame(mod.out, 
                               n.asvs = dim(y)[2], n.samples = dim(y)[1],
                               Comp = row.names(mod.out), 
                               row.names=NULL, stringsAsFactors = F)
      mod.out.df$community <- names(waplsdata.list)[[i]]
      mod.out.df$respVar <- stem.respVars[[k]]
    }
    k.list[[k]] <- mod.out.df
    #capture.output(mod.out.df, file = "output/tables/wapls_S2_resids.txt", append = T)
  }
  names(k.list) <- unlist(stem.respVars)
  i.list[[i]] <- k.list
}
warnings()
names(i.list) <- names(waplsdata.list)
tib <- tibble(data = i.list)
tib %>%
  unnest(data) %>%
  unnest(cols = c(data)) -> tibtab
tibtab %>%
  group_by(community, respVar) %>%
  summarize(n.asvs1 = unique(n.asvs),
            n.samples1 = unique(n.samples),
            comp1.p = p[Comp == "Comp01"],
            comp1.signif = comp1.p < 0.05,
            comp1.r2 = R2[Comp == "Comp01"]) -> tibtab.summ
tibtab.summ$slice <- "S2_resid"
tibtab.summ
write.csv(tibtab.summ, file = "output/tables/wapls_S2_resid.csv")
read.csv(file = "output/tables/wapls_S2_resid.csv")

# signif
tibtab.summ %>%
  filter(comp1.signif == TRUE)

```
None are significant

___________________
# SAVE STUFF

read in all the output files and create summaries
```{r}
a <- read.csv(file = "output/tables/wapls_C1.csv", row.names = 1)
b <- read.csv(file = "output/tables/wapls_C2.csv", row.names = 1)
c <- read.csv(file = "output/tables/wapls_S1.csv", row.names = 1)
d <- read.csv(file = "output/tables/wapls_S2.csv", row.names = 1)
e <- read.csv(file = "output/tables/wapls_C1_resid.csv", row.names = 1)
f <- read.csv(file = "output/tables/wapls_C2_resid.csv", row.names = 1)
g <- read.csv(file = "output/tables/wapls_S1_resid.csv", row.names = 1)
h <- read.csv(file = "output/tables/wapls_S2_resid.csv", row.names = 1)
df <- rbind(a, b, c, d, e, f, g, h)
df %>%
  mutate(comp1.r2 = round(comp1.r2, digits = 2)) %>%
  mutate(comp1.p = ifelse(comp1.p < 0.1, comp1.p, "lessThan0.1")) %>%
  select(slice, community, respVar, n.asvs1, n.samples1, comp1.p, comp1.r2) -> df.out

df.out %>%
  filter(is.na(comp1.p))

df.out %>%
  filter(comp1.p != "lessThan0.1")
  
write.csv(df.out, file = "output/tables/wapls_ALL.csv")
```



