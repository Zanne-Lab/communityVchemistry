---
title: "Does chemistry or community better predict mass loss?"
author: "Marissa Lee"
date: "10/23/2017"
output: github_document
---


```{r, echo=FALSE, message=FALSE}
#chunk options
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)

#libraries
devtools::install_github("cornwell-lab-unsw/litterfitter")
library(dplyr)
library(ggplot2)
library(readr)
library(vegan)
library(knitr)
library(litterfitter)
library(magrittr)
library(tidyr)
library(gridExtra)
library(rioja)
library(colorspace)

#fxns
source("code/load_fxns.R")
source("code/curve_fitting_fxns.R")
source("code/distance_fxns.R")
source("code/otuIDs_fxns.R")
```

### Load microbial community data
```{r, echo=FALSE}
#stem sample meta data
#stemSamples<-load_stemSamples() #uncomment if the data changes
#write_csv(stemSamples, "derived_data/stemSamples.csv")
stemSamples<-read_csv("derived_data/stemSamples.csv")

#OTU table
#fung.otu<-load_matotu() #uncomment if the data changes
#comm.otu<-add_oomycetes(fung.otu) #add the oomycetes #uncomment if the data changes
#write.csv(comm.otu, "derived_data/comm_otu.csv")
comm.otu<-read.csv("derived_data/comm_otu.csv", row.names=1)

#create sequence sample meta data table
#seqSamples<-load_seqSamples(comm.otu, stemSamples) #uncomment if the data changes
#write_csv(seqSamples, "derived_data/seqSamples.csv")
seqSamples<-read_csv("derived_data/seqSamples.csv")

#taxon lookup info
#taxAndFunguild<-load_TaxAndFunguild(comm.otu) #uncomment if the data changes
#write_csv(taxAndFunguild, "derived_data/taxaAndFunguild.csv")
taxAndFunguild<-read_csv("derived_data/taxaAndFunguild.csv")

#plot_sampleEffortCurves(comm.otu)
```

### Load wood trait data
```{r, echo=FALSE}
#traits.mean<-mergeTraitData() #uncomment if the data changes
#write_csv(traits.mean, "derived_data/traits_mean.csv") 
traits.mean<-read_csv("derived_data/traits_mean.csv")
#missing data
#traits.long<-as.data.frame(gather(traits.mean, key=trait, value=value, -(1:3)))
#filter(traits.long, is.na(value))

traits.codeStem<-mergeTraitData_byStem()
#data that we have
traits.codeStem.long<-as.data.frame(gather(traits.codeStem, key=trait, value=value, -(1:3)))
traits.codeStem.long %>%
  filter(!is.na(value)) %>%
  group_by(code, trait) %>%
  summarize(length(value)) %>%
  spread(key=trait, value='length(value)') -> tmp

### LOAD MASS LOSS DATA and CALCULATE % MASS REMAINING AT EACH TIMEPOINT
#initial_mass <- read_in_initial_mass() #uncomment if the data changes
#harvest_mass<-LoadHarvestFiles()
#mass.data<-bind_rows(initial_mass, harvest_mass)
#missing data
#mass.data %>% filter(is.na(totalSampleDryMass))
#plotting_df<-Calc_massRemaining(mass.data)
#matching failures
# plotting_df %>%
#   filter(is.na(pmr)) %>%
#   select(unique, species, size, time, totalSampleDryMass, notes) %>%
#   spread(key=time, value=totalSampleDryMass)
#remove NAs
#plotting_df %>% filter(!is.na(pmr)) -> plotting_df
#write.csv(plotting_df,"derived_data/plotting_df.csv")
plotting_df<-read.csv("derived_data/plotting_df.csv", row.names=1)

#add codeStem and transform
plotting_df %>%
  select(unique, size, time, pmr) %>%
  separate(unique, into=c("code","StemNposition"), sep=4, extra='merge', remove=FALSE) %>%
  separate(StemNposition, into=c("Stem","position"), sep=1, extra='merge', remove=TRUE) %>%
  mutate(codeStem=paste(code, Stem, sep="")) %>%
  select(codeStem, position, time, pmr) -> pmr.df

#average pmr by codeStem and time
pmr.df %>%
  group_by(codeStem, time) %>%
  summarize(mean.pmr=mean(pmr, na.rm=TRUE),
            sd.pmr=sd(pmr, na.rm=TRUE),
            n.pmr=length(pmr)) -> pmr.byStem.df

pmr.byStem.df$code<-substr(pmr.byStem.df$codeStem, 1, 4)
pmr.byStem.df$species<-tolower(pmr.byStem.df$code)
pmr.byStem.df$size<-"large"
pmr.byStem.df[pmr.byStem.df$code == tolower(pmr.byStem.df$code),"size"]<-"small"
ggplot(pmr.byStem.df, aes(x=time, y=mean.pmr, group=codeStem, color=species, linetype=size)) + 
  geom_line() + facet_wrap(~species)

#make it wide
pmr.byStem.df %>%
  select(codeStem, time, mean.pmr) %>%
  spread(key=time, value=mean.pmr) %>%
  rename('time0'=`0`,
         'time7'=`7`,
         'time13'=`13`,
         'time25'=`25`,
         'time37'=`37`) -> pmr.byStem.df.w

### CALCULATE DECAY TRAJECTORY FITS
#spdf <- fit_all_curves(plotting_df) #this recalculates all the curve fits, uncomment if the data changes
#indx<-select(stemSamples, code, species, size)
#spdf<-left_join(spdf, indx) #add code
#write_csv(spdf,"derived_data/mass_loss_parameters.csv")
spdf <- read_csv("derived_data/mass_loss_parameters.csv")
# ggplot(spdf,aes(x=t70,y=w.t70,col=size))+
#   geom_point()+
#   labs(x="Time to 30% mass loss (negative exponential)", 
#        y="Time to 30% mass loss (Weibull)")+
#   geom_abline(slope=1,intercept=0,linetype="dashed")+theme_bw()


```


##########################################

## Wood traits as a predictor

*Hyp:* Stem-specific initial wood traits will predict variation in percent mass loss.
```{r}

#function to pull out samples with complete trait info
CreateTraitPMRpair<-function(timePoint, traits.codeStem, pmr.byStem.df.w){
  
  #make a dataframe using the current time point's pmr and remove NAs
  pmr.byStem.df.w %>%
    select_("codeStem",timePoint) %>%
    rename_("curr.time"=timePoint) %>%
    filter(!is.na(curr.time)) -> pmr.noNAs
  
  #subset the trait matrix using these unique codeStems
  traits.codeStem %>%
    filter(codeStem %in% pmr.noNAs$codeStem) -> curr.traits
  
  #most complete trait set
  curr.traits %>%
    filter(!is.na(waterperc) & !is.na(P) & !is.na(K) & !is.na(Ca) & !is.na(Mn) & !is.na(Fe) & !is.na(Zn) & !is.na(N) & !is.na(C)) -> curr.traits
  #curr.traits<-curr.traits[complete.cases(curr.traits),] #so few if you do this..

  #get rid of pmr rows for which there is missing trait data
  pmr.noNAs %>%
    filter(codeStem %in% curr.traits$codeStem) -> curr.pmr
    
  #merge the dataframes
  curr.df<-left_join(curr.pmr, curr.traits) 
  
  #add code and species and size
  curr.df<-separate(curr.df, col=codeStem, into=c("code","Stem"), sep=4, remove=FALSE)
  curr.df$species<-tolower(curr.df$code)
  curr.df$size<-"large"
  curr.df[curr.df$code == tolower(curr.df$code),"size"]<-"small"
  
  return(curr.df)
    
  }

timeList<-list('time7','time13','time25','time37')

#very few complete cases of wood traits on stem-level
#density and barkthick only on small stems
datasets<-lapply(timeList, CreateTraitPMRpair, traits.codeStem, pmr.byStem.df.w)
names(datasets)<-c('time7','time13','time25','time37')

#fit full models (no barkthick or density because these weren't measured on small stems)
mod.full.t7<-lm(curr.time ~ size + waterperc + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time7']])
mod.full.t13<-lm(curr.time ~ size + waterperc + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time13']])
mod.full.t25<-lm(curr.time ~ size + waterperc + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time25']])
mod.full.t37<-lm(curr.time ~ size + waterperc + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time37']])

#do stepwise model selection
mod.select.t7<-step(mod.full.t7, direction="backward")
mod.select.t13<-step(mod.full.t13, direction="backward")
mod.select.t25<-step(mod.full.t25, direction="backward")
mod.select.t37<-step(mod.full.t37, direction="backward")

#save the residuals
traitResid.t7<- data.frame(codeStem = datasets[['time7']]$codeStem, trait.resid = mod.select.t7$residuals)
traitResid.t13<- data.frame(codeStem = datasets[['time13']]$codeStem, trait.resid = mod.select.t13$residuals)
traitResid.t25<- data.frame(codeStem = datasets[['time25']]$codeStem, trait.resid = mod.select.t25$residuals)
traitResid.t37<- data.frame(codeStem = datasets[['time37']]$codeStem, trait.resid = mod.select.t37$residuals)

```

### time7 

**less water content and C leads to more mass remaining after 7 months**  

```{r, echo=FALSE}
summary(mod.select.t7) # waterperc, C (marginally)
#ggplot(datasets[['time7']], aes(x=waterperc, y=curr.time*100, color=species)) + 
#  geom_point() + ylab("Mass remaining after 7 months (%)")
```

### time 13

**larger size stems, less water content, more P and Mn, and less N leads to more mass remaining after 13 months**  

```{r, echo=FALSE}
summary(mod.select.t13) # size, waterperc, N
#ggplot(datasets[['time13']], aes(x=waterperc, y=curr.time*100, color=species, size=N)) + 
#  geom_point() + ylab("Mass remaining after 13 months (%)") + facet_grid(~size)
```

### time 25

**larger size stems, less water content, more P leads to more mass remaining after 25 months**  

```{r, echo=FALSE}
summary(mod.select.t25) # size, waterperc, P
ggplot(datasets[['time25']], aes(x=waterperc, y=curr.time*100, color=species, size=P)) + 
  geom_point() + ylab("Mass remaining after 25 months (%)") + facet_grid(~size)
```

### time 37

**larger size stems, less water content, more P leads to more mass remaining after 37 months**  

```{r, echo=FALSE}
summary(mod.select.t37) # size, waterperc, P
ggplot(datasets[['time37']], aes(x=waterperc, y=curr.time*100, color=species, size=P)) + 
  geom_point() + ylab("Mass remaining after 37 months (%)") + facet_grid(~size)
```



*Hyp:* Variation in wood traits will lead to differences in decay model fit (r2), rate (k), and lagginess (alpha).  Specifically, we expect samples with (a) high waterperc, (b) low density and C, (c) high P, K, Ca, Mn, Fe, Zn, and N, and (d) thicker bark (potential mech: limiting microbial colonization) to have better-fiting decay models (r2), faster decay rates (k), and less lagginess (alpha). 
```{r, include=FALSE}

#merge into 1 df
spdf %>%
  select(code, species, size, ne.r2, k, t70, alpha) %>%
  left_join(traits.mean) %>% 
  filter(!is.na(P)) %>%
  filter(!is.na(waterperc)) -> spdf.traits

#fit full models
mod.full.r<-lm(ne.r2 ~ size + waterperc + density + barkthick + P + K + Ca + Mn + Fe + Zn + N + C, data=spdf.traits)
mod.full.k<-lm(k ~ size + waterperc + density + barkthick + P + K + Ca + Mn + Fe + Zn + N + C, data=spdf.traits)
mod.full.t70<-lm(t70 ~ size + waterperc + density + barkthick + P + K + Ca + Mn + Fe + Zn + N + C, data=spdf.traits)
mod.full.alpha<-lm(alpha ~ size + waterperc + density + barkthick + P + K + Ca + Mn + Fe + Zn + N + C, data=spdf.traits)

#do stepwise model selection
mod.select.r<-step(mod.full.r, direction="backward")
mod.select.k<-step(mod.full.k, direction="backward")
mod.select.t70<-step(mod.full.t70, direction="backward")
mod.select.alpha<-step(mod.full.alpha, direction="backward")

#save the residuals
trait.residuals<-data.frame(code=spdf.traits$code,
  r2.resid=mod.select.r$residuals,
  k.resid=mod.select.k$residuals,
  t70.resid=mod.select.t70$residuals,
  alpha.resid=mod.select.alpha$residuals)

```

### r2  

**greater water content and greater Zn and N leads to better-fitting decay models**  

Note: This result changed when I changed waterperc to g water/g wet weight. When waterperc was in terms of g/g dry weight, the best model that greater water content and less C leads to better-fitting decay models
```{r, echo=FALSE}
summary(mod.select.r) # waterperc, Zn, N
#ggplot(spdf.traits, aes(x=waterperc, y=ne.r2, color=species, shape=size)) + geom_point()
```

### k  

**small size stems, greater water content, thinner bark, less Ca, more Zn, and more N lead to faster decay**

NOTE from Will: Density explains the same part of the variation in decay rates that initial water content does, only less well.  (In other words, although, density gets dropped from the best model by the model selection procedure, if we remove initial water from consideration entirely, density is included in the model as the best predictor.)  

So my current interpretation is that wood water rentention--related to fiber saturation point and partially captured by the density measurement--has a strong effect on long-term decomposition rates, possibly by maintaining fungal activity further into dry periods.  There is also a very likely interaction between this water retention capacity with the fungal community (see results in Setting the Stage paper, Lee et al. in review).

```{r, echo=FALSE}
summary(mod.select.k) # size, waterperc, barkthick, Ca, Zn, N

ggplot(spdf.traits, aes(x=waterperc, y=k)) + geom_point(aes(color=species)) + facet_grid(~size) +
  labs(y="k (year^-1)",x="Initial water content (% wet weight)")+geom_smooth(method="lm",se=FALSE)+theme_bw()


ggplot(spdf.traits, aes(x=density, y=k)) + geom_point(aes(color=species)) + facet_grid(~size) +
  labs(y="k (year^-1)",x="Initial density (g/cm^3)")+geom_smooth(method="lm",se=FALSE)+theme_bw()

```

### t70  

**small stem sizes, less water content, thicker bark, more Ca, less Zn, and less N lead to longer wood "70%"-lives**  

Note: This result changed when I changed waterperc to g water/g wet weight. When waterperc was in terms of g/g dry weight, the best model indicated that large size stems, less water content, more Ca, and less Zn lead to longer wood "70%"-lives
```{r, echo=FALSE}
summary(mod.select.t70) # size, waterperc, barkthick, Ca, Zn
#ggplot(spdf.traits, aes(x=waterperc, y=t70, color=species, size=density)) + geom_point() + facet_grid(~size)
```

### alpha--- don't interpret yet
```{r, include=FALSE}
summary(mod.select.alpha) # density, Zn, C
```




##########################################

## Community as a predictor

### First, filter community matrix to include only taxa that are present in a least 20% of all the samples. This step removes taxa that may not contribute much to our understanding of the relationship between species’ multivariate abundance and environment.
```{r, echo=FALSE}

minSamps<-floor(dim(comm.otu)[1] * .2) #how many samples is 20% of them?
dat1 <- apply(comm.otu>0, 2, sum) #how many samples does each OTU show up in?
comm.otu.trimmed <- comm.otu[,dat1>minSamps]

paste("Keep", dim(comm.otu.trimmed)[2], "of", dim(comm.otu)[2], "OTUs")

```


*Hyp:* Stem-specific initial microbial communitiy compositions will predict variation in percent mass loss, particularly in the early stages of decay.
```{r}

#fxns
reformatMatrix<-function(commmat){
  newmat<-matrix(as.numeric(as.matrix(commmat)), ncol=dim(commmat)[2], nrow=dim(commmat)[1])
  return(newmat)
}
CreateCommPMRpair<-function(timePoint, comm.mat, pmr.byStem.df.w){
    
  #make a dataframe using the current time point's pmr and remove NAs
  pmr.byStem.df.w %>%
    select_("codeStem",timePoint) %>%
    rename_("curr.time"=timePoint) %>%
    filter(!is.na(curr.time)) -> pmr.noNAs
  
  #subset the community matrix using these unique codeStems
  curr.comm<-comm.mat[row.names(comm.mat) %in% pmr.noNAs$codeStem,]
  curr.comm<-curr.comm[,colSums(curr.comm) != 0] #get rid of any OTU columns with all 0s
    
  #get rid of pmr rows for which there is missing community data
  pmr.noNAs %>%
    filter(codeStem %in% row.names(curr.comm)) -> curr.pmr
    
    #make sure the row orders match
    ord<-match(row.names(curr.comm), curr.pmr$codeStem)
    curr.pmr<-curr.pmr[ord,]
    
    #reformat the community matrix
    curr.comm.reform<-reformatMatrix(curr.comm)
    row.names(curr.comm.reform)<-row.names(curr.comm)
    colnames(curr.comm.reform)<-colnames(curr.comm)
    
    modelDat.list<-list(pmr=curr.pmr, comm=curr.comm.reform)
    
    return(modelDat.list)
    
  }

timeList<-list('time7','time13','time25','time37')
datasets<-lapply(timeList, CreateCommPMRpair, comm.mat = comm.otu.trimmed, pmr.byStem.df.w)
names(datasets)<-c('time7','time13','time25','time37')
datasets.nt<-lapply(timeList, CreateCommPMRpair, comm.mat = comm.otu, pmr.byStem.df.w)
names(datasets.nt)<-c('time7','time13','time25','time37')

#fit models
fit.t7 <- WAPLS(datasets[['time7']][['comm']], datasets[['time7']][['pmr']]$curr.time)
fit.t13 <- WAPLS(datasets[['time13']][['comm']], datasets[['time13']][['pmr']]$curr.time)
fit.t25 <- WAPLS(datasets[['time25']][['comm']], datasets[['time25']][['pmr']]$curr.time)
fit.t37 <- WAPLS(datasets[['time37']][['comm']], datasets[['time37']][['pmr']]$curr.time)
fit.t7.notrim <- WAPLS(datasets.nt[['time7']][['comm']], datasets.nt[['time7']][['pmr']]$curr.time)
fit.t13.notrim <- WAPLS(datasets.nt[['time13']][['comm']], datasets.nt[['time13']][['pmr']]$curr.time)
fit.t25.notrim <- WAPLS(datasets.nt[['time25']][['comm']], datasets.nt[['time25']][['pmr']]$curr.time)
fit.t37.notrim <- WAPLS(datasets.nt[['time37']][['comm']], datasets.nt[['time37']][['pmr']]$curr.time)

#cross-validate models using the leave-one-out method
fit.t7.cv <- crossval(fit.t7, cv.method="loo")
fit.t13.cv <- crossval(fit.t13, cv.method="loo")
fit.t25.cv <- crossval(fit.t25, cv.method="loo")
fit.t37.cv <- crossval(fit.t37, cv.method="loo")
fit.t7.nt.cv <- crossval(fit.t7.notrim, cv.method="loo")
fit.t13.nt.cv <- crossval(fit.t13.notrim, cv.method="loo")
fit.t25.nt.cv <- crossval(fit.t25.notrim, cv.method="loo")
fit.t37.nt.cv <- crossval(fit.t37.notrim, cv.method="loo")

#perform randomization t-test to test the significance of a cross-validated model....
```

### time 7

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.t7.cv) 
rand.t.test(fit.t7.nt.cv)
```

### time 13

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.t13.cv) 
rand.t.test(fit.t13.nt.cv) #marginally-significant Comp02
```

### time 25

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.t25.cv) 
rand.t.test(fit.t25.nt.cv)
```

### time 37

**Comp01 is significant**
**if trim out OTUs that are not present in at least 20% of samples...Comp02 is marginally significant**

```{r, echo=FALSE}
rand.t.test(fit.t37.cv) # signif Comp02
rand.t.test(fit.t37.nt.cv) #signif Comp01
```

Investigate the biology underlying time37-associated coefs for Comp02
```{r, include=FALSE}
coef.comp<-fit.t37.cv$coefficients[,'Comp02']
coef.comp.df<-data.frame(OTUId=names(coef.comp), coefComp=coef.comp)

#create df of OTU taxon and guild info matched with coef value
coef.comp.df %>% left_join(taxAndFunguild) -> coef.comp.ann
unique(coef.comp.ann$kingdom)

```
By trophic mode (note that apparently empty cateogies have at least 1 data point, the violin plot just doesn't show it)
```{r, include=FALSE}
#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Trophic.Mode)))
names(colvals)<-unique(coef.comp.ann$Trophic.Mode)
colvals['unclassified']<-"#D3D3D3"

ggplot(coef.comp.ann, aes(x=reorder(genus,coefComp), y=coefComp, color=Trophic.Mode)) + 
  geom_point() + coord_flip() +
  xlab("Fungal genus") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Trophic mode", values=colvals) +
  theme_classic() +
  geom_hline(yintercept=0, linetype=2)

#color the genus axis labels by asco/basidio


```
By guild (note that apparently empty cateogies have at least 1 data point, the violin plot just doesn't show it)
```{r, include=FALSE}
#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Guild)))
names(colvals)<-unique(coef.comp.ann$Guild)
colvals['unclassified']<-"#D3D3D3"

ggplot(coef.comp.ann, aes(x=reorder(genus,coefComp), y=coefComp, color=Guild)) + 
  geom_point() + coord_flip() +
  xlab("Fungal genus") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Guild", values=colvals) +
  theme_classic() +
  geom_hline(yintercept=0, linetype=2)

#color the genus axis labels by asco/basidio

```



*Hyp:* Average initial microbial communitiy compositions will predict variation in decay model fit (r2), rate (k), and lagginess (alpha).
```{r, include=FALSE, results=FALSE, message=FALSE}

#average OTU abundances by code
meanOTUabund.trim<-AverageOTUabund_byCode(comm.otu, seqSamples)
meanOTUabund.trim2<-AverageOTUabund_byCode(comm.otu.trimmed, seqSamples)

#get rid of spdf rows for which there is missing community data... this is eusc
#spdf[!spdf$code %in% row.names(meanOTUabund.trim),]$code
spdf.trim<-spdf[spdf$code %in% row.names(meanOTUabund.trim2),]

#fit models
fit.r2.notrim <- WAPLS(meanOTUabund.trim, spdf.trim$ne.r2)
fit.r2 <- WAPLS(meanOTUabund.trim2, spdf.trim$ne.r2)
fit.k <- WAPLS(meanOTUabund.trim2, spdf.trim$k)
fit.t70 <- WAPLS(meanOTUabund.trim2, spdf.trim$t70)
fit.alpha <- WAPLS(meanOTUabund.trim2, spdf.trim$alpha)

#cross-validate models using the leave-one-out method
fit.r2.cv.notrim <- crossval(fit.r2.notrim, cv.method="loo")
fit.r2.cv <- crossval(fit.r2, cv.method="loo")
fit.k.cv <- crossval(fit.k, cv.method="loo")
fit.t70.cv <- crossval(fit.t70, cv.method="loo")
fit.alpha.cv <- crossval(fit.alpha, cv.method="loo")

#rand.t.test(fit.alpha.cv) #perform randomization t-test to test the significance of a cross-validated model
#screeplot(fit.r2.cv)

```

### r2  

**none of the community components are significant predictors**

```{r, echo=FALSE}
#rand.t.test(fit.r2.cv)
rand.t.test(fit.r2.cv.notrim)
```

### k

**none of the community components are significant predictors**
```{r, echo=FALSE}
rand.t.test(fit.k.cv)
```

### t70

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.t70.cv)
```

### alpha --- don't interpret yet
```{r, include=FALSE}
rand.t.test(fit.alpha.cv)
```




##########################################

## Community+traits as a predictor

*Hyp:* After accounting for variation in decay due to wood traits (no models with barkthick or density), stem-specific initial microbial communitiy compositions will predict variation in percent mass loss, particularly in the early stages of decay.

```{r, include=FALSE, results=FALSE, message=FALSE}
#run rioja::WAPLS on wood trait residuals

#fxns
CreateCommTraitResidpair<-function(timePoint, comm.mat, traitResid){
  
  #there should be no NAs in the current time point's traitResid
  traitResid %>%
    filter(!is.na(trait.resid)) -> traitResid.noNAs
  
  #subset the community matrix using these unique codeStems
  curr.comm<-comm.mat[row.names(comm.mat) %in% traitResid.noNAs$codeStem,]
  curr.comm<-curr.comm[,colSums(curr.comm) != 0] #get rid of any OTU columns with all 0s
    
  #get rid of traitResid rows for which there is missing community data
  traitResid.noNAs %>%
    filter(codeStem %in% row.names(curr.comm)) -> curr.traitResid
  
  #make sure the row orders match
    ord<-match(row.names(curr.comm), curr.traitResid$codeStem)
    curr.traitResid<-curr.traitResid[ord,]
    
    #reformat the community matrix
    curr.comm.reform<-reformatMatrix(curr.comm)
    row.names(curr.comm.reform)<-row.names(curr.comm)
    colnames(curr.comm.reform)<-colnames(curr.comm)
    
    modelDat.list<-list(traitresid=curr.traitResid, comm=curr.comm.reform)
    
    return(modelDat.list)
    
}

dataset.t7<-CreateCommTraitResidpair(timePoint="time7", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t7)
dataset.t13<-CreateCommTraitResidpair(timePoint="time13", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t13)
dataset.t25<-CreateCommTraitResidpair(timePoint="time25", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t25)
dataset.t37<-CreateCommTraitResidpair(timePoint="time37", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t37)

dataset.t7.notrim<-CreateCommTraitResidpair(timePoint="time7", comm.mat = comm.otu, 
                                      traitResid = traitResid.t7)
dataset.t13.notrim<-CreateCommTraitResidpair(timePoint="time13", comm.mat = comm.otu, 
                                      traitResid = traitResid.t13)
dataset.t25.notrim<-CreateCommTraitResidpair(timePoint="time25", comm.mat = comm.otu, 
                                      traitResid = traitResid.t25)
dataset.t37.notrim<-CreateCommTraitResidpair(timePoint="time37", comm.mat = comm.otu, 
                                      traitResid = traitResid.t37)


#fit models
fit.tr.t7 <- WAPLS(dataset.t7[['comm']], dataset.t7[['traitresid']]$trait.resid)
fit.tr.t13 <- WAPLS(dataset.t13[['comm']], dataset.t13[['traitresid']]$trait.resid)
fit.tr.t25 <- WAPLS(dataset.t25[['comm']], dataset.t25[['traitresid']]$trait.resid)
fit.tr.t37 <- WAPLS(dataset.t37[['comm']], dataset.t37[['traitresid']]$trait.resid)
fit.tr.t7.nt <- WAPLS(dataset.t7.notrim[['comm']], dataset.t7.notrim[['traitresid']]$trait.resid)
fit.tr.t13.nt <- WAPLS(dataset.t13.notrim[['comm']], dataset.t13.notrim[['traitresid']]$trait.resid)
fit.tr.t25.nt <- WAPLS(dataset.t25.notrim[['comm']], dataset.t25.notrim[['traitresid']]$trait.resid)
fit.tr.t37.nt <- WAPLS(dataset.t37.notrim[['comm']], dataset.t37.notrim[['traitresid']]$trait.resid)

#cross-validate models using the leave-one-out method
fit.tr.t7.cv <- crossval(fit.tr.t7, cv.method="loo")
fit.tr.t13.cv <- crossval(fit.tr.t13, cv.method="loo")
fit.tr.t25.cv <- crossval(fit.tr.t25, cv.method="loo")
fit.tr.t37.cv <- crossval(fit.tr.t37, cv.method="loo")
fit.tr.t7.cv.nt <- crossval(fit.tr.t7.nt, cv.method="loo")
fit.tr.t13.cv.nt <- crossval(fit.tr.t13.nt, cv.method="loo")
fit.tr.t25.cv.nt <- crossval(fit.tr.t25.nt, cv.method="loo")
fit.tr.t37.cv.nt <- crossval(fit.tr.t37.nt, cv.method="loo")

#rand.t.test(fit.alpha.cv) #perform randomization t-test to test the significance of a cross-validated model
#screeplot(fit.r2.cv)

```

### time 7

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.tr.t7.cv) 
#rand.t.test(fit.tr.t7.cv.nt)
```

### time 13

**Comp02 is significant**
**if trim out OTUs that are not present in at least 20% of samples...no components are significant**

```{r, echo=FALSE}
rand.t.test(fit.tr.t13.cv) 
rand.t.test(fit.tr.t13.cv.nt) 
```

Investigate the biology underlying time13-associated coefs for Comp02
```{r, include=FALSE}
coef.comp<-fit.tr.t13.cv.nt$coefficients[,'Comp02']
coef.comp.df<-data.frame(OTUId=names(coef.comp), coefComp=coef.comp)

#create df of OTU taxon and guild info matched with coef value
coef.comp.df %>% left_join(taxAndFunguild) -> coef.comp.ann

#classify samples into quantiles based on coef value
quant<-quantile(coef.comp.ann$coefComp, c(.05, .95))
coef.comp.ann$quant<-"middle"
coef.comp.ann[coef.comp.ann$coefComp > quant[2],'quant']<-"upper95"
coef.comp.ann[coef.comp.ann$coefComp < quant[1],'quant']<-"lower5"
plot.df<-subset(coef.comp.ann, quant != "middle") #get rid of the middle for plotting
unique(plot.df$kingdom)

```
By trophic mode
```{r, echo=FALSE, warnings=FALSE, message=FALSE}

#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Trophic.Mode)))
names(colvals)<-unique(coef.comp.ann$Trophic.Mode)
colvals['unclassified']<-"#D3D3D3"

pTroph<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=Trophic.Mode)) + 
  geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
  xlab("Fungal species") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Trophic mode", values=colvals) +
  theme_classic()
pTroph

totallower<-sum(plot.df$quant=="lower5")
totalupper<-sum(plot.df$quant=="upper95")

plot.df %>%
  group_by(Trophic.Mode, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(Trophic.Mode != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(Trophic.Mode, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Trophic mode")


```

```{r, include=FALSE}
#by guild

# #define cols
# colvals<-rainbow_hcl(length(unique(coef.comp.ann$Guild)))
# names(colvals)<-unique(coef.comp.ann$Guild)
# colvals['unclassified']<-"#D3D3D3"
# 
# pGuild<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=Guild)) + 
#   geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
#   xlab("Fungal species") + ylab("Component coefficient estimate") +
#   scale_color_manual(name="Guild", values=colvals) +
#   theme_classic()
# pGuild
# 
# plot.df %>%
#   group_by(Guild, quant) %>%
#   summarize(numOTUs=length(coefComp),
#             freqlower=numOTUs/totallower,
#             frequpper=numOTUs/totalupper) %>%
#   filter(Guild != "unclassified") -> tmp
# tmp$freq<-tmp$freqlower 
# tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]
# 
# ggplot(tmp, aes(x=reorder(Guild, freq), y=freq*100)) + 
#   geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
#   ylab("OTU frequency (%)") + xlab("Guild")

```

By phylum
```{r, include=FALSE}

# #define cols
# colvals<-rainbow_hcl(length(unique(coef.comp.ann$phylum)))
# names(colvals)<-unique(coef.comp.ann$phylum)
# colvals['unclassified']<-"#D3D3D3"
# 
# pPhylum<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=phylum)) + 
#   geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
#   xlab("Fungal species") + ylab("Component coefficient estimate") +
#   scale_color_manual(name="Phylum", values=colvals) +
#   theme_classic()
# pPhylum

plot.df %>%
  group_by(phylum, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(phylum != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(phylum, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Phylum")

```



### time 25

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.tr.t25.cv) 
#rand.t.test(fit.tr.t25.cv.nt)
```

### time 37

**none of the community components are significant predictors**

```{r, echo=FALSE}
rand.t.test(fit.tr.t37.cv) 
#rand.t.test(fit.tr.t37.cv.nt) 
```





*Hyp:* After accounting for variation in decay due to wood traits, average initial microbial communitiy compositions will predict variation in decay model fit (r2), rate (k), and lagginess (alpha).

```{r, include=FALSE, results=FALSE, message=FALSE}
#run rioja::WAPLS on wood trait residuals

#average OTU abundances by code
meanOTUabund.trim2<-AverageOTUabund_byCode(comm.otu.trimmed, seqSamples)

#make sure that the residuals and community dataframes are aligned
trait.residuals$code<-as.character(trait.residuals$code)
trait.residuals[!trait.residuals$code %in% row.names(meanOTUabund.trim2),"code"] # no missing from meanOTUabund.trim
row.names(meanOTUabund.trim2)[!row.names(meanOTUabund.trim2) %in% trait.residuals$code] #missing olst from trait.residuals
trait.residuals.trim<-trait.residuals[trait.residuals$code %in% row.names(meanOTUabund.trim2),] #trim
meanOTUabund.trim3<-meanOTUabund.trim2[row.names(meanOTUabund.trim2) %in% trait.residuals.trim$code,] #trim
ord<-match(row.names(meanOTUabund.trim3), trait.residuals.trim$code)
trait.residuals.trim.o<-trait.residuals.trim[ord,]
sum(trait.residuals.trim.o$code != row.names(meanOTUabund.trim3)) #this needs to by 0

#make sure there are no empty OTU cols
sum(colSums(meanOTUabund.trim3)==0)

#fit models
fit.tr.r2 <- WAPLS(meanOTUabund.trim3, trait.residuals.trim.o$r2.resid)
fit.tr.k <- WAPLS(meanOTUabund.trim3, trait.residuals.trim.o$k.resid)
fit.tr.t70 <- WAPLS(meanOTUabund.trim3, trait.residuals.trim.o$t70.resid)
fit.tr.alpha <- WAPLS(meanOTUabund.trim3, trait.residuals.trim.o$alpha.resid)

#cross-validate models using the leave-one-out method
fit.tr.r2.cv <- crossval(fit.tr.r2, cv.method="loo")
fit.tr.k.cv <- crossval(fit.tr.k, cv.method="loo")
fit.tr.t70.cv <- crossval(fit.tr.t70, cv.method="loo")
fit.tr.alpha.cv <- crossval(fit.tr.alpha, cv.method="loo")

#rand.t.test(fit.alpha.cv) #perform randomization t-test to test the significance of a cross-validated model
#screeplot(fit.r2.cv)

```


### r2  

**none of the community components are significant predictors**  

Note: This result changed when I changed waterperc to g water/g wet weight. When waterperc was in terms of g/g dry weight, Comp05 was marginally significant
```{r, echo=FALSE}
rand.t.test(fit.tr.r2.cv)
```

### k  

**none of the community components are significant predictors**  

```{r, echo=FALSE}
rand.t.test(fit.tr.k.cv)
```

### t70  

**none of the community components are significant predictors**  

Note: This result changed when I changed waterperc to g water/g wet weight. When waterperc was in terms of g/g dry weight, Comp05 was a significant predictor
```{r, echo=FALSE}
rand.t.test(fit.tr.t70.cv) 
```

### alpha --- don't interpret yet
```{r, include=FALSE}
rand.t.test(fit.tr.alpha.cv)
```

**Note: no longer warrented based on analyses with waterperc represented as g water / g wet weight...**

Investigate the biology underlying t70-associated coefs for Comp05
```{r, include=FALSE}
#coef.comp5<-fit.tr.t70.cv$coefficients[,'Comp05']
#coef.comp5.df<-data.frame(OTUId=names(coef.comp5), coefComp5=coef.comp5)

#create df of OTU taxon and guild info matched with coef value
#coef.comp5.df %>% left_join(taxAndFunguild) -> coef.comp5.ann
```
By trophic mode (note that apparently empty cateogies have at least 1 data point, the violin plot just doesn't show it)
```{r, include=FALSE}
#ggplot(coef.comp5.ann, aes(x=Trophic.Mode, y=coefComp5)) + geom_violin() + coord_flip()
```
By guild (note that apparently empty cateogies have at least 1 data point, the violin plot just doesn't show it)
```{r, include=FALSE}
#ggplot(coef.comp5.ann, aes(x=Guild, y=coefComp5)) + geom_violin() + coord_flip()
```
By phylum
```{r, include=FALSE}
#ggplot(coef.comp5.ann, aes(x=phylum, y=coefComp5)) + geom_violin() + coord_flip()
```





##########################################

## Diversity (and diversity of specific clades) as a predictor  

**Note that the full community matrix was used for these analyses**

*Hyp:* Greater microbial diversity (richness, Shannon diversity, ... add phylogenetic diversity) will lead to better-fitting decay models (ne.r2), faster decay (k), and less lagginess (alpha) because of the selection effect for fast decayers and complementarity among taxa for decay.  
Hyp-Alt: Greater microbial diversity will lead to worse-fitting decay models (ne.r2), slower decay (k), and more lagginess (alpha) because taxa will be allocating more of their resources to combat one another.
```{r, echo=FALSE}

# summarize the diversity in each sample
rich.df<-Calc_richOTU(taxAndFunguild, comm.otu)
H.df<-Calc_H.OTU(taxAndFunguild, comm.otu)

# create a merged df wtih spdf
rich.spdf<-Create_rich_spdf_DF(otutype.df=rich.df, spdf)
H.spdf<-Create_rich_spdf_DF(otutype.df=H.df, spdf)

# fit models
mod.rich.r2<-lm(ne.r2~size+mean, data=rich.spdf)
mod.rich.k<-lm(k~size+mean, data=rich.spdf)
mod.rich.t70<-lm(t70~size+mean, data=rich.spdf)
mod.rich.alpha<-lm(alpha~size+mean, data=rich.spdf)

mod.H.r2<-lm(ne.r2~size+mean, data=H.spdf)
mod.H.k<-lm(k~size+mean, data=H.spdf)
mod.H.t70<-lm(t70~size+mean, data=H.spdf)
mod.H.alpha<-lm(alpha~size+mean, data=H.spdf)

# create plots
richList<-Plot_richOTUtype(rich.spdf=rich.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Total")
H.List<-Plot_richOTUtype(rich.spdf=H.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Shannon's H")

```

### Richness

**No pattern**
```{r, echo=FALSE}
anova(mod.rich.r2)
anova(mod.rich.k)
anova(mod.rich.t70)
anova(mod.rich.alpha)
```

### Shannon's H

**No pattern**
```{r, echo=FALSE}
anova(mod.H.r2)
anova(mod.H.k)
anova(mod.H.t70)
anova(mod.H.alpha)
```

*Hyp:* Greater saprotroph and basidiomycete richness will lead to better-fitting decay models (ne.r2), faster decay (k), and less lagginess (alpha) because the community does not need to wait for the arrival of key decayers to act on the wood substrate.  
Hyp-Alt: Greater saprotroph and basidiomycete richness will lead to worse-fitting decay models (ne.r2), slower decay (k), and more lagginess (alpha) because decayers will be allocating more of their resources to combat one another.
```{r, echo=FALSE}

# summarize the presence of ... in each sample
sapro.df<-Calc_richOTUtype(colNam="Trophic.Mode", grepTerm="Sapro", taxAndFunguild, comm.otu=comm.otu)  
basidio.df<-Calc_richOTUtype(colNam="phylum", grepTerm="Basid", taxAndFunguild, comm.otu=comm.otu)

# create a merged df wtih spdf
saprorich.spdf<-Create_rich_spdf_DF(otutype.df=sapro.df, spdf)
basidrich.spdf<-Create_rich_spdf_DF(otutype.df=basidio.df, spdf)

# fit models
mod.sapro.r2<-lm(ne.r2~size+mean, data=saprorich.spdf)
mod.sapro.k<-lm(k~size+mean, data=saprorich.spdf)
mod.sapro.t70<-lm(t70~size+mean, data=saprorich.spdf)
mod.sapro.alpha<-lm(alpha~size+mean, data=saprorich.spdf)
mod.basid.r2<-lm(ne.r2~size+mean, data=basidrich.spdf)
mod.basid.k<-lm(k~size+mean, data=basidrich.spdf)
mod.basid.t70<-lm(t70~size+mean, data=basidrich.spdf)
mod.basid.alpha<-lm(alpha~size+mean, data=basidrich.spdf)

# create plots
sapList<-Plot_richOTUtype(rich.spdf=saprorich.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Saprotroph")
basidList<-Plot_richOTUtype(rich.spdf = basidrich.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Basidio")

```

### Saprotroph richness

**No pattern**

```{r, echo=FALSE}
anova(mod.sapro.r2)
anova(mod.sapro.k)
anova(mod.sapro.t70)
anova(mod.sapro.alpha) #marginally-signif
#sapList[['alpha']]
```

### Basidio richness

**No pattern**

```{r, echo=FALSE}
anova(mod.basid.r2)
anova(mod.basid.k)
anova(mod.basid.t70)
anova(mod.basid.alpha)
```


*Hyp:* Greater pathogen and oomycete richness will lead to worse-fitting decay models (ne.r2), slower decay (k), and more lagginess (alpha) because the presence of these organisms will inhibit the establishment and activity of decayers.
```{r, echo=FALSE}

# summarize the presence of ... in each sample
path.df<-Calc_richOTUtype(colNam="Trophic.Mode", grepTerm="Patho", taxAndFunguild, comm.otu=comm.otu)
oomy.df<-Calc_richOTUtype(colNam="kingdom", grepTerm="Protist", taxAndFunguild, comm.otu=comm.otu) # have to do this with the full community matrix because there are so few of these guys

# create a merged df wtih spdf
pathrich.spdf<-Create_rich_spdf_DF(otutype.df=path.df, spdf)
oomyrich.spdf<-Create_rich_spdf_DF(otutype.df=oomy.df, spdf)

# fit models
mod.path.r2<-lm(ne.r2~size+mean, data=pathrich.spdf)
mod.path.k<-lm(k~size+mean, data=pathrich.spdf)
mod.path.t70<-lm(t70~size+mean, data=pathrich.spdf)
mod.path.alpha<-lm(alpha~size+mean, data=pathrich.spdf)
mod.oomy.r2<-lm(ne.r2~size+mean, data=oomyrich.spdf)
mod.oomy.k<-lm(k~size+mean, data=oomyrich.spdf)
mod.oomy.t70<-lm(t70~size+mean, data=oomyrich.spdf)
mod.oomy.alpha<-lm(alpha~size+mean, data=oomyrich.spdf)

# create plots
pathList<-Plot_richOTUtype(rich.spdf=pathrich.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Pathogen")
ooList<-Plot_richOTUtype(rich.spdf=oomyrich.spdf, 
                        valueCol_vec=c("ne.r2", "k","alpha"), 
                        otutypeNam="Oomycete")

```

### Pathogen richness

**No pattern**

```{r, echo=FALSE}
anova(mod.path.r2)
anova(mod.path.k)
anova(mod.path.t70)
anova(mod.path.alpha) #marginally signif
#pathList[['alpha']]
```

### Oomycete richness

**No pattern**

```{r, echo=FALSE}
anova(mod.oomy.r2)
anova(mod.oomy.k)
anova(mod.oomy.t70)
anova(mod.oomy.alpha)
```




##############################################

## Diversity plus traits as a predictor

*Hyp:* After accounting for variation in decay due to wood traits, average initial microbial diversity (richness, Shannon diversity, ... add phylogenetic diversity) will predict variation in decay model fit (r2), rate (k), and lagginess (alpha).

```{r, echo=FALSE}

#run lm mods on wood trait residuals
mod.rich<-FitResid_diversity(rich.spdf=rich.spdf, trait.residuals)
mod.H<-FitResid_diversity(rich.spdf=H.spdf, trait.residuals)
mod.sapro<-FitResid_diversity(rich.spdf=saprorich.spdf, trait.residuals)
mod.basid<-FitResid_diversity(rich.spdf=basidrich.spdf, trait.residuals)
mod.path<-FitResid_diversity(rich.spdf=pathrich.spdf, trait.residuals)
mod.oomy<-FitResid_diversity(rich.spdf=oomyrich.spdf, trait.residuals)

#make plots
p.rich<-PlotResid_diversity(rich.spdf=rich.spdf, trait.residuals, xlab="Richness")
p.H<-PlotResid_diversity(rich.spdf=H.spdf, trait.residuals, xlab="Shannon's H")
p.sapro<-PlotResid_diversity(rich.spdf=saprorich.spdf, trait.residuals, xlab="Saprotroph richness")
p.basid<-PlotResid_diversity(rich.spdf=basidrich.spdf, trait.residuals, xlab="Basidio richness")
p.path<-PlotResid_diversity(rich.spdf=pathrich.spdf, trait.residuals, xlab="Pathogen richness")
p.oomy<-PlotResid_diversity(rich.spdf=oomyrich.spdf, trait.residuals, xlab="Oomycete richness")

```

### Richness

**No pattern**

```{r, echo=FALSE}
lapply(mod.rich, anova)
```

### Shannon's H

**No pattern**

```{r, echo=FALSE}
lapply(mod.H, anova)
```

### Saprotroph richness

**No pattern**

```{r, echo=FALSE}
lapply(mod.sapro, anova) #marginally signif alpha
#summary(mod.sapro[['alpha']])
#p.sapro[['alpha']]
```

### Basidio richness

**No pattern**

```{r, echo=FALSE}
lapply(mod.basid, anova)
```

### Pathogen richness

**No pattern**

```{r, echo=FALSE}
lapply(mod.path, anova) #marginally signif for alpha
#summary(mod.path[['alpha']])
#p.path[['alpha']]
```

### Oomycete richness

**No pattern**

```{r, echo=FALSE}
lapply(mod.oomy, anova)
```




##############################################

## Relationship between wood traits and community
*Hyp:* Average initial microbial communitiy compositions will covary with initial wood traits

```{r}

#average OTU abundances by code
meanOTUabund.trim2<-AverageOTUabund_byCode(comm.otu.trimmed, seqSamples)

#get rid of missing data from traits.mean
traits.mean %>%
  filter(!is.na(waterperc)) %>% #get NaN row
  filter(code %in% row.names(meanOTUabund.trim2)) -> traits.mean.trim #get rid of rows for which there is missing community data... this is eusc

#make sure dimensions of the community matrix match
meanOTUabund.trim3<-meanOTUabund.trim2[row.names(meanOTUabund.trim2) %in% traits.mean.trim$code,]

#make a envVars matrix for model fitting
envVars<-as.matrix(traits.mean.trim[,-(1:3)])

#fit models
fit.cca <- cca(meanOTUabund.trim3 ~ envVars)
fit.cca
plot(fit.cca)
anova(fit.cca)


```



##############################################

## Extra pieces

1. *code/testing_time_zero.Rmd* -- Including t=0 points to fit decay model affects the liklihood and the model selection criteria, but the curve fits are identical with this formulation.  Excluding the t=0 fits has an effect of prefering simpler models, which is the same effect as increasing the penalty for model complexity. 

2. *code/initialDist_vs_decayDist_btwCode.Rmd* -- No apparent relationship between species+size dissimilarities in initial microbial community composition (bray and jaccard) and decay trajectory params

3. *code/boralOTUpairs_vs_decay.Rmd* -- No apparent relationship between frequency of boral-ID'd positively/negatively correlated OTU pairs and decay params

4. *code/withinInitialDist_vs_decayR2.Rmd* -- No apparent relationship between initial microbial diversity WITHIN species+size and decay model R2

5. *code/unexpectedTaxa.Rmd* -- Mycorrhizal fungi and animal-associated fungi that somehow made it into our OTU table





