---
title: "Does chemistry or community better predict mass loss?"
author: "Marissa Lee"
date: "10/23/2017"
output: github_document
---


```{r, echo=FALSE, message=FALSE}
#chunk options
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)

#libraries
devtools::install_github("cornwell-lab-unsw/litterfitter")
library(dplyr)
library(ggplot2)
library(readr)
library(vegan)
library(knitr)
library(litterfitter)
library(magrittr)
library(tidyr)
library(gridExtra)
library(rioja)
library(colorspace)

#fxns
source("code/load_fxns.R")
source("code/curve_fitting_fxns.R")
source("code/distance_fxns.R")
source("code/otuIDs_fxns.R")
```

### Load microbial community data
```{r, echo=FALSE}
#stem sample meta data
#stemSamples<-load_stemSamples() #uncomment if the data changes
#write_csv(stemSamples, "derived_data/stemSamples.csv")
stemSamples<-read_csv("derived_data/stemSamples.csv")

#OTU table
#fung.otu<-load_matotu() #uncomment if the data changes
#comm.otu<-add_oomycetes(fung.otu) #add the oomycetes #uncomment if the data changes
#write.csv(comm.otu, "derived_data/comm_otu.csv")
comm.otu<-read.csv("derived_data/comm_otu.csv", row.names=1)

#create sequence sample meta data table
#seqSamples<-load_seqSamples(comm.otu, stemSamples) #uncomment if the data changes
#write_csv(seqSamples, "derived_data/seqSamples.csv")
seqSamples<-read_csv("derived_data/seqSamples.csv")

#taxon lookup info
#taxAndFunguild<-load_TaxAndFunguild(comm.otu) #uncomment if the data changes
#write_csv(taxAndFunguild, "derived_data/taxaAndFunguild.csv")
taxAndFunguild<-read_csv("derived_data/taxaAndFunguild.csv")

#plot_sampleEffortCurves(comm.otu)
```

### Load wood trait data
```{r, echo=FALSE}
#traits.mean<-mergeTraitData() #uncomment if the data changes
#write_csv(traits.mean, "derived_data/traits_mean.csv") 
traits.mean<-read_csv("derived_data/traits_mean.csv")
#missing data
#traits.long<-as.data.frame(gather(traits.mean, key=trait, value=value, -(1:3)))
#filter(traits.long, is.na(value))

traits.codeStem<-mergeTraitData_byStem()
#data that we have
traits.codeStem.long<-as.data.frame(gather(traits.codeStem, key=trait, value=value, -(1:3)))
traits.codeStem.long %>%
  filter(!is.na(value)) %>%
  group_by(code, trait) %>%
  summarize(length(value)) %>%
  spread(key=trait, value='length(value)') -> tmp

### LOAD MASS LOSS DATA and CALCULATE % MASS REMAINING AT EACH TIMEPOINT
#initial_mass <- read_in_initial_mass() #uncomment if the data changes
#harvest_mass<-LoadHarvestFiles()
#mass.data<-bind_rows(initial_mass, harvest_mass)
#missing data
#mass.data %>% filter(is.na(totalSampleDryMass))
#plotting_df<-Calc_massRemaining(mass.data)
#matching failures
# plotting_df %>%
#   filter(is.na(pmr)) %>%
#   select(unique, species, size, time, totalSampleDryMass, notes) %>%
#   spread(key=time, value=totalSampleDryMass)
#remove NAs
#plotting_df %>% filter(!is.na(pmr)) -> plotting_df
#write.csv(plotting_df,"derived_data/plotting_df.csv")
plotting_df<-read.csv("derived_data/plotting_df.csv", row.names=1)

#add codeStem and transform
plotting_df %>%
  select(unique, size, time, pmr) %>%
  separate(unique, into=c("code","StemNposition"), sep=4, extra='merge', remove=FALSE) %>%
  separate(StemNposition, into=c("Stem","position"), sep=1, extra='merge', remove=TRUE) %>%
  mutate(codeStem=paste(code, Stem, sep="")) %>%
  select(codeStem, position, time, pmr) -> pmr.df

#average pmr by codeStem and time
pmr.df %>%
  group_by(codeStem, time) %>%
  summarize(mean.pmr=mean(pmr, na.rm=TRUE),
            sd.pmr=sd(pmr, na.rm=TRUE),
            n.pmr=length(pmr)) -> pmr.byStem.df

pmr.byStem.df$code<-substr(pmr.byStem.df$codeStem, 1, 4)
pmr.byStem.df$species<-tolower(pmr.byStem.df$code)
pmr.byStem.df$size<-"large"
pmr.byStem.df[pmr.byStem.df$code == tolower(pmr.byStem.df$code),"size"]<-"small"
ggplot(pmr.byStem.df, aes(x=time, y=mean.pmr, group=codeStem, color=species, linetype=size)) + 
  geom_line() + facet_wrap(~species)

#make it wide
pmr.byStem.df %>%
  select(codeStem, time, mean.pmr) %>%
  spread(key=time, value=mean.pmr) %>%
  rename('time0'=`0`,
         'time7'=`7`,
         'time13'=`13`,
         'time25'=`25`,
         'time37'=`37`) -> pmr.byStem.df.w

### CALCULATE DECAY TRAJECTORY FITS
#spdf <- fit_all_curves(plotting_df) #this recalculates all the curve fits, uncomment if the data changes
#indx<-select(stemSamples, code, species, size)
#spdf<-left_join(spdf, indx) #add code
#write_csv(spdf,"derived_data/mass_loss_parameters.csv")
spdf <- read_csv("derived_data/mass_loss_parameters.csv")
# ggplot(spdf,aes(x=t70,y=w.t70,col=size))+
#   geom_point()+
#   labs(x="Time to 30% mass loss (negative exponential)", 
#        y="Time to 30% mass loss (Weibull)")+
#   geom_abline(slope=1,intercept=0,linetype="dashed")+theme_bw()


```


##########################################

# Wood traits as a predictor

First, look at just the small stem samples because we have the most trait information on the stem level for theses samples. Compare models using data on code level and codeStem level and with barkthickness and density as predictors to see if codeStem improves model fit...
```{r, echo=FALSE}

# add code to pmr dataset
pmr.byStem.df.w %>%
  separate(codeStem, into=c("code","Stem"), sep=4, extra='merge', remove=FALSE) -> pmr.byStem.df.w

# (1) subset just the small stems
# (2) subset samples with waterperc, density, barkthick trait data
# (3) join with pmr data
# (4) select useful cols
traits.codeStem %>% 
  filter(size=="small") %>%
  filter(!is.na(density) & !is.na(barkthick)) %>%
  left_join(pmr.byStem.df.w) %>%
  select(codeStem, code, size, density, barkthick, time7, time13, time25, time37) -> sm.traits.codeStem
dim(sm.traits.codeStem)


# (1) subset just the small codes, 
# (2) subset samples with waterperc, density, barkthick trait data
# (3) restrict analyses to the same set of wood species as present in stem dataset
# (4) join with pmr data
# (5) select useful cols
traits.mean %>%
  filter(size=="small") %>%
  filter(!is.na(density) & !is.na(barkthick)) %>%
  filter(code %in% unique(sm.traits.codeStem$code)) %>%
  left_join(pmr.byStem.df.w) %>%
  select(codeStem, code, size, density, barkthick, time7, time13, time25, time37) -> sm.traits.code
dim(sm.traits.code)

### density + barkthick
#fit stem-level models
mod.stem.t7<-lm(time7 ~ density + barkthick, data=sm.traits.codeStem)
mod.stem.t13<-lm(time13 ~ density +barkthick, data=sm.traits.codeStem)
mod.stem.t25<-lm(time25 ~ density +barkthick, data=sm.traits.codeStem)
mod.stem.t37<-lm(time37 ~ density +barkthick, data=sm.traits.codeStem)
#fit code-level models
mod.code.t7<-lm(time7 ~ density +barkthick, data=sm.traits.code)
mod.code.t13<-lm(time13 ~ density +barkthick, data=sm.traits.code)
mod.code.t25<-lm(time25 ~ density +barkthick, data=sm.traits.code)
mod.code.t37<-lm(time37 ~ density +barkthick, data=sm.traits.code)
#summarize r2 vals
mod.compare.densitybarkthick<-data.frame(response=c("time7","time13","time25","time37"),
           r2.stem=c(summary(mod.stem.t7)$r.squared,
                     summary(mod.stem.t13)$r.squared,
                     summary(mod.stem.t25)$r.squared,
                     summary(mod.stem.t37)$r.squared),
           
           r2.code=c(summary(mod.code.t7)$r.squared,
                     summary(mod.code.t13)$r.squared,
                     summary(mod.code.t25)$r.squared,
                     summary(mod.code.t37)$r.squared))
mod.compare.densitybarkthick

### just barkthick
#fit stem-level models
mod.stem.t7<-lm(time7 ~ barkthick, data=sm.traits.codeStem)
mod.stem.t13<-lm(time13 ~ barkthick, data=sm.traits.codeStem)
mod.stem.t25<-lm(time25 ~ barkthick, data=sm.traits.codeStem)
mod.stem.t37<-lm(time37 ~ barkthick, data=sm.traits.codeStem)
#fit code-level models
mod.code.t7<-lm(time7 ~ barkthick, data=sm.traits.code)
mod.code.t13<-lm(time13 ~ barkthick, data=sm.traits.code)
mod.code.t25<-lm(time25 ~ barkthick, data=sm.traits.code)
mod.code.t37<-lm(time37 ~ barkthick, data=sm.traits.code)
#summarize r2 vals
mod.compare.barkthick<-data.frame(response=c("time7","time13","time25","time37"),
           r2.stem=c(summary(mod.stem.t7)$r.squared,
                     summary(mod.stem.t13)$r.squared,
                     summary(mod.stem.t25)$r.squared,
                     summary(mod.stem.t37)$r.squared),
           
           r2.code=c(summary(mod.code.t7)$r.squared,
                     summary(mod.code.t13)$r.squared,
                     summary(mod.code.t25)$r.squared,
                     summary(mod.code.t37)$r.squared))
mod.compare.barkthick

#ggplot(sm.traits.codeStem, aes(x=codeStem, y=barkthick, color=code)) + 
#  geom_point() + coord_flip()

```
For models with **density + barkthickness**, it looks like stem-level data improves model fit a tiny bit for early percent mass remaining time points (after 7 and 13 months) but not later time points. For models with just **barkthickness**, fits are about the same... slightly better on the stem-level at the last time point

## *Hyp (stem-level)* Stem-specific initial wood traits will predict variation in percent mass loss.
```{r, include=FALSE}

CreateTraitPMRpair<-function(timePoint, traits.codeStem, traits.mean, pmr.byStem.df.w){
  
  #make a dataframe using the current time point's pmr and remove NAs
  pmr.byStem.df.w %>%
    select_("codeStem",timePoint) %>%
    rename_("curr.time"=timePoint) %>%
    filter(!is.na(curr.time)) -> pmr.noNAs
  
  #subset the trait matrix using these unique codeStems
  traits.codeStem %>%
    filter(codeStem %in% pmr.noNAs$codeStem) -> curr.traits
  
  #stem-level trait set
  curr.traits %>%
    filter(!is.na(waterperc) & !is.na(P) & !is.na(K) & !is.na(Ca) & !is.na(Mn) & !is.na(Fe) & !is.na(Zn) & !is.na(N) & !is.na(C)) -> curr.traits
  
  #add species-level traits
  traits.mean %>%
    select(code, barkthick) %>%
    rename('barkthick_smspp'='barkthick')-> select.traits.mean
  curr.traits %>%
    left_join(select.traits.mean) -> curr.traits
  
  #get rid of pmr rows for which there is missing trait data
  pmr.noNAs %>%
    filter(codeStem %in% curr.traits$codeStem) -> curr.pmr
    
  #merge the dataframes
  curr.df<-left_join(curr.pmr, curr.traits) 
  #add code and species and size
  curr.df<-separate(curr.df, col=codeStem, into=c("code","Stem"), sep=4, remove=FALSE)
  curr.df$species<-tolower(curr.df$code)
  curr.df$size<-"large"
  curr.df[curr.df$code == tolower(curr.df$code),"size"]<-"small"
  
  return(curr.df)
    
  }

timeList<-list('time7','time13','time25','time37')

#function to pull out samples with the following trait info ...
# stem-level waterperc, xrf, and CN and (small) species-level barkthickness
datasets<-lapply(timeList, CreateTraitPMRpair, traits.codeStem, traits.mean, pmr.byStem.df.w)
names(datasets)<-c('time7','time13','time25','time37')

#fit full models (no barkthick or density because these weren't measured on small stems)
mod.full.t7<-lm(curr.time ~ size + waterperc + barkthick_smspp + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time7']])
mod.full.t13<-lm(curr.time ~ size + waterperc + barkthick_smspp + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time13']])
mod.full.t25<-lm(curr.time ~ size + waterperc + barkthick_smspp + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time25']])
mod.full.t37<-lm(curr.time ~ size + waterperc + barkthick_smspp + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time37']])
mod.full.t37.nobark<-lm(curr.time ~ size + waterperc + P + K + Ca + Mn + Fe + Zn + N + C, data=datasets[['time37']])

#do stepwise model selection
mod.select.t7<-step(mod.full.t7, direction="backward")
mod.select.t13<-step(mod.full.t13, direction="backward")
mod.select.t25<-step(mod.full.t25, direction="backward")
mod.select.t37<-step(mod.full.t37, direction="backward")
mod.select.t37.nobark<-step(mod.full.t37.nobark, direction="backward")

#save the residuals
traitResid.t7<- data.frame(codeStem = datasets[['time7']]$codeStem, trait.resid = mod.select.t7$residuals)
traitResid.t13<- data.frame(codeStem = datasets[['time13']]$codeStem, trait.resid = mod.select.t13$residuals)
traitResid.t25<- data.frame(codeStem = datasets[['time25']]$codeStem, trait.resid = mod.select.t25$residuals)
traitResid.t37<- data.frame(codeStem = datasets[['time37']]$codeStem, trait.resid = mod.select.t37$residuals)

```

### time7 

**less water content and C leads to more mass remaining after 7 months**  

```{r, echo=FALSE}
summary(mod.select.t7) # waterperc, C (marginally)
#ggplot(datasets[['time7']], aes(x=waterperc, y=curr.time*100, color=species)) + 
#  geom_point() + ylab("Mass remaining after 7 months (%)")
```

### time 13

**larger size stems, less water content, more P and Mn, and less N leads to more mass remaining after 13 months**  

```{r, echo=FALSE}
summary(mod.select.t13) # size, waterperc, N
#ggplot(datasets[['time13']], aes(x=waterperc, y=curr.time*100, color=species, size=N)) + 
#  geom_point() + ylab("Mass remaining after 13 months (%)") + facet_grid(~size)
```

### time 25

**larger size stems, less water content, more P leads to more mass remaining after 25 months**  

```{r, echo=FALSE}
summary(mod.select.t25) # size, waterperc, P
#ggplot(datasets[['time25']], aes(x=waterperc, y=curr.time*100, color=species, size=P)) + 
#  geom_point() + ylab("Mass remaining after 25 months (%)") + facet_grid(~size)
```

### time 37

**larger size stems, less water content, less thick bark, more P, Mn, and C leads to more mass remaining after 37 months**  

```{r, echo=FALSE}
summary(mod.select.t37) # size, waterperc, barkthick_smspp, P, Mn, C
#ggplot(datasets[['time37']], aes(x=waterperc, y=curr.time*100, color=species, size=P)) + 
#  geom_point() + ylab("Mass remaining after 37 months (%)") + facet_grid(~size)

summary(mod.select.t37.nobark)
```




##########################################

# Community as a predictor

### First, filter community matrix to include only taxa that are present in a least 20% of all the samples. This step removes taxa that may not contribute much to our understanding of the relationship between species’ multivariate abundance and environment.
```{r, echo=FALSE}

minSamps<-floor(dim(comm.otu)[1] * .2) #how many samples is 20% of them?
dat1 <- apply(comm.otu>0, 2, sum) #how many samples does each OTU show up in?
comm.otu.trimmed <- comm.otu[,dat1>minSamps]

paste("Keep", dim(comm.otu.trimmed)[2], "of", dim(comm.otu)[2], "OTUs")

```


## *Hyp (stem-level)* Stem-specific initial microbial communitiy compositions will predict variation in percent mass loss, particularly in the early stages of decay.
```{r, include=FALSE}

#fxns
reformatMatrix<-function(commmat){
  newmat<-matrix(as.numeric(as.matrix(commmat)), ncol=dim(commmat)[2], nrow=dim(commmat)[1])
  return(newmat)
}
CreateCommPMRpair<-function(timePoint, comm.mat, pmr.byStem.df.w){
    
  #make a dataframe using the current time point's pmr and remove NAs
  pmr.byStem.df.w %>%
    select_("codeStem",timePoint) %>%
    rename_("curr.time"=timePoint) %>%
    filter(!is.na(curr.time)) -> pmr.noNAs
  
  #subset the community matrix using these unique codeStems
  curr.comm<-comm.mat[row.names(comm.mat) %in% pmr.noNAs$codeStem,]
  curr.comm<-curr.comm[,colSums(curr.comm) != 0] #get rid of any OTU columns with all 0s
    
  #get rid of pmr rows for which there is missing community data
  pmr.noNAs %>%
    filter(codeStem %in% row.names(curr.comm)) -> curr.pmr
    
    #make sure the row orders match
    ord<-match(row.names(curr.comm), curr.pmr$codeStem)
    curr.pmr<-curr.pmr[ord,]
    
    #reformat the community matrix
    curr.comm.reform<-reformatMatrix(curr.comm)
    row.names(curr.comm.reform)<-row.names(curr.comm)
    colnames(curr.comm.reform)<-colnames(curr.comm)
    
    modelDat.list<-list(pmr=curr.pmr, comm=curr.comm.reform)
    
    return(modelDat.list)
    
  }

timeList<-list('time7','time13','time25','time37')
datasets<-lapply(timeList, CreateCommPMRpair, comm.mat = comm.otu.trimmed, pmr.byStem.df.w)
names(datasets)<-c('time7','time13','time25','time37')
datasets.nt<-lapply(timeList, CreateCommPMRpair, comm.mat = comm.otu, pmr.byStem.df.w)
names(datasets.nt)<-c('time7','time13','time25','time37')

#fit models
fit.t7 <- WAPLS(datasets[['time7']][['comm']], datasets[['time7']][['pmr']]$curr.time)
fit.t13 <- WAPLS(datasets[['time13']][['comm']], datasets[['time13']][['pmr']]$curr.time)
fit.t25 <- WAPLS(datasets[['time25']][['comm']], datasets[['time25']][['pmr']]$curr.time)
fit.t37 <- WAPLS(datasets[['time37']][['comm']], datasets[['time37']][['pmr']]$curr.time)
fit.t7.notrim <- WAPLS(datasets.nt[['time7']][['comm']], datasets.nt[['time7']][['pmr']]$curr.time)
fit.t13.notrim <- WAPLS(datasets.nt[['time13']][['comm']], datasets.nt[['time13']][['pmr']]$curr.time)
fit.t25.notrim <- WAPLS(datasets.nt[['time25']][['comm']], datasets.nt[['time25']][['pmr']]$curr.time)
fit.t37.notrim <- WAPLS(datasets.nt[['time37']][['comm']], datasets.nt[['time37']][['pmr']]$curr.time)

#cross-validate models using the leave-one-out method
fit.t7.cv <- crossval(fit.t7, cv.method="loo")
fit.t13.cv <- crossval(fit.t13, cv.method="loo")
fit.t25.cv <- crossval(fit.t25, cv.method="loo")
fit.t37.cv <- crossval(fit.t37, cv.method="loo")
fit.t7.nt.cv <- crossval(fit.t7.notrim, cv.method="loo")
fit.t13.nt.cv <- crossval(fit.t13.notrim, cv.method="loo")
fit.t25.nt.cv <- crossval(fit.t25.notrim, cv.method="loo")
fit.t37.nt.cv <- crossval(fit.t37.notrim, cv.method="loo")

#perform randomization t-test to test the significance of a cross-validated model....
#rand.t.test(fit.t7.cv) 
#rand.t.test(fit.t7.nt.cv)
#rand.t.test(fit.t13.cv) 
#rand.t.test(fit.t13.nt.cv) #marginally-significant Comp02
#rand.t.test(fit.t25.cv) 
#rand.t.test(fit.t25.nt.cv)
```

### time 7, 13, and 25

**none of the community components are significant predictors**

### time 37

**Comp01 is significant; if trim out OTUs that are not present in at least 20% of samples...Comp02 is significant**

```{r, echo=FALSE}
rand.t.test(fit.t37.cv) # signif Comp02
rand.t.test(fit.t37.nt.cv) #signif Comp01
```

Investigate the biology underlying time37-associated coefs for Comp02
```{r, echo=FALSE, message=FALSE, warning=FALSE}
coef.comp<-fit.t37.cv$coefficients[,'Comp02']
coef.comp.df<-data.frame(OTUId=names(coef.comp), coefComp=coef.comp)

#create df of OTU taxon and guild info matched with coef value
coef.comp.df %>% left_join(taxAndFunguild) -> coef.comp.ann
unique(coef.comp.ann$kingdom)

```
By trophic mode
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Trophic.Mode)))
names(colvals)<-unique(coef.comp.ann$Trophic.Mode)
colvals['unclassified']<-"#D3D3D3"

ggplot(coef.comp.ann, aes(x=reorder(genus,coefComp), y=coefComp, color=Trophic.Mode)) + 
  geom_point() + coord_flip() +
  xlab("Fungal genus") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Trophic mode", values=colvals) +
  theme_classic() +
  geom_hline(yintercept=0, linetype=2)

#color the genus axis labels by asco/basidio


```




##########################################

# Community+traits as a predictor

## *Hyp1 (stem-level)* After accounting for variation in decay due to wood traits (no models with barkthick or density), stem-specific initial microbial communitiy compositions will predict variation in percent mass loss, particularly in the early stages of decay.

```{r, include=FALSE, results=FALSE, message=FALSE}
#run rioja::WAPLS on wood trait residuals

#fxns
CreateCommTraitResidpair<-function(timePoint, comm.mat, traitResid){
  
  #there should be no NAs in the current time point's traitResid
  traitResid %>%
    filter(!is.na(trait.resid)) -> traitResid.noNAs
  
  #subset the community matrix using these unique codeStems
  curr.comm<-comm.mat[row.names(comm.mat) %in% traitResid.noNAs$codeStem,]
  curr.comm<-curr.comm[,colSums(curr.comm) != 0] #get rid of any OTU columns with all 0s
    
  #get rid of traitResid rows for which there is missing community data
  traitResid.noNAs %>%
    filter(codeStem %in% row.names(curr.comm)) -> curr.traitResid
  
  #make sure the row orders match
    ord<-match(row.names(curr.comm), curr.traitResid$codeStem)
    curr.traitResid<-curr.traitResid[ord,]
    
    #reformat the community matrix
    curr.comm.reform<-reformatMatrix(curr.comm)
    row.names(curr.comm.reform)<-row.names(curr.comm)
    colnames(curr.comm.reform)<-colnames(curr.comm)
    
    modelDat.list<-list(traitresid=curr.traitResid, comm=curr.comm.reform)
    
    return(modelDat.list)
    
}

dataset.t7<-CreateCommTraitResidpair(timePoint="time7", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t7)
dataset.t13<-CreateCommTraitResidpair(timePoint="time13", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t13)
dataset.t25<-CreateCommTraitResidpair(timePoint="time25", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t25)
dataset.t37<-CreateCommTraitResidpair(timePoint="time37", comm.mat = comm.otu.trimmed, 
                                      traitResid = traitResid.t37)

dataset.t7.notrim<-CreateCommTraitResidpair(timePoint="time7", comm.mat = comm.otu, 
                                      traitResid = traitResid.t7)
dataset.t13.notrim<-CreateCommTraitResidpair(timePoint="time13", comm.mat = comm.otu, 
                                      traitResid = traitResid.t13)
dataset.t25.notrim<-CreateCommTraitResidpair(timePoint="time25", comm.mat = comm.otu, 
                                      traitResid = traitResid.t25)
dataset.t37.notrim<-CreateCommTraitResidpair(timePoint="time37", comm.mat = comm.otu, 
                                      traitResid = traitResid.t37)


#fit models
fit.tr.t7 <- WAPLS(dataset.t7[['comm']], dataset.t7[['traitresid']]$trait.resid)
fit.tr.t13 <- WAPLS(dataset.t13[['comm']], dataset.t13[['traitresid']]$trait.resid)
fit.tr.t25 <- WAPLS(dataset.t25[['comm']], dataset.t25[['traitresid']]$trait.resid)
fit.tr.t37 <- WAPLS(dataset.t37[['comm']], dataset.t37[['traitresid']]$trait.resid)
fit.tr.t7.nt <- WAPLS(dataset.t7.notrim[['comm']], dataset.t7.notrim[['traitresid']]$trait.resid)
fit.tr.t13.nt <- WAPLS(dataset.t13.notrim[['comm']], dataset.t13.notrim[['traitresid']]$trait.resid)
fit.tr.t25.nt <- WAPLS(dataset.t25.notrim[['comm']], dataset.t25.notrim[['traitresid']]$trait.resid)
fit.tr.t37.nt <- WAPLS(dataset.t37.notrim[['comm']], dataset.t37.notrim[['traitresid']]$trait.resid)

#cross-validate models using the leave-one-out method
fit.tr.t7.cv <- crossval(fit.tr.t7, cv.method="loo")
fit.tr.t13.cv <- crossval(fit.tr.t13, cv.method="loo")
fit.tr.t25.cv <- crossval(fit.tr.t25, cv.method="loo")
fit.tr.t37.cv <- crossval(fit.tr.t37, cv.method="loo")
fit.tr.t7.cv.nt <- crossval(fit.tr.t7.nt, cv.method="loo")
fit.tr.t13.cv.nt <- crossval(fit.tr.t13.nt, cv.method="loo")
fit.tr.t25.cv.nt <- crossval(fit.tr.t25.nt, cv.method="loo")
fit.tr.t37.cv.nt <- crossval(fit.tr.t37.nt, cv.method="loo")

#rand.t.test(fit.alpha.cv) #perform randomization t-test to test the significance of a cross-validated model
#rand.t.test(fit.tr.t7.cv) 
#rand.t.test(fit.tr.t7.cv.nt)
#rand.t.test(fit.tr.t25.cv) 
#rand.t.test(fit.tr.t25.cv.nt)
rand.t.test(fit.tr.t37.cv) 
rand.t.test(fit.tr.t37.cv.nt) 

```

### time 7, 25

**none of the community components are significant predictors**

### time 13

**Comp02 is significant, but if trim out OTUs that are not present in at least 20% of samples then no components are significant**

```{r, echo=FALSE}
rand.t.test(fit.tr.t13.cv) 
rand.t.test(fit.tr.t13.cv.nt) 
```

Investigate the biology underlying time13-associated coefs for Comp02
```{r, include=FALSE}
coef.comp<-fit.tr.t13.cv.nt$coefficients[,'Comp02']
coef.comp.df<-data.frame(OTUId=names(coef.comp), coefComp=coef.comp)

#create df of OTU taxon and guild info matched with coef value
coef.comp.df %>% left_join(taxAndFunguild) -> coef.comp.ann

#classify samples into quantiles based on coef value
quant<-quantile(coef.comp.ann$coefComp, c(.05, .95))
coef.comp.ann$quant<-"middle"
coef.comp.ann[coef.comp.ann$coefComp > quant[2],'quant']<-"upper95"
coef.comp.ann[coef.comp.ann$coefComp < quant[1],'quant']<-"lower5"
plot.df<-subset(coef.comp.ann, quant != "middle") #get rid of the middle for plotting
unique(plot.df$kingdom)

```
By trophic mode
```{r, echo=FALSE, warnings=FALSE, message=FALSE}

#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Trophic.Mode)))
names(colvals)<-unique(coef.comp.ann$Trophic.Mode)
colvals['unclassified']<-"#D3D3D3"

pTroph<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=Trophic.Mode)) + 
  geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
  xlab("Fungal species") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Trophic mode", values=colvals) +
  theme_classic()
pTroph

totallower<-sum(plot.df$quant=="lower5")
totalupper<-sum(plot.df$quant=="upper95")

plot.df %>%
  group_by(Trophic.Mode, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(Trophic.Mode != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(Trophic.Mode, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Trophic mode")


```
By phylum
```{r, echo=FALSE, warnings=FALSE, message=FALSE}

# #define cols
# colvals<-rainbow_hcl(length(unique(coef.comp.ann$phylum)))
# names(colvals)<-unique(coef.comp.ann$phylum)
# colvals['unclassified']<-"#D3D3D3"
# 
# pPhylum<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=phylum)) + 
#   geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
#   xlab("Fungal species") + ylab("Component coefficient estimate") +
#   scale_color_manual(name="Phylum", values=colvals) +
#   theme_classic()
# pPhylum

plot.df %>%
  group_by(phylum, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(phylum != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(phylum, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Phylum")

```

### time 37

**Comp02 is significant, but if trim out OTUs that are not present in at least 20% of samples then no components are significant**

```{r, echo=FALSE}
rand.t.test(fit.tr.t37.cv) 
rand.t.test(fit.tr.t37.cv.nt) 
```

Investigate the biology underlying time37-associated coefs for Comp02
```{r, include=FALSE}
coef.comp<-fit.tr.t37.cv.nt$coefficients[,'Comp02']
coef.comp.df<-data.frame(OTUId=names(coef.comp), coefComp=coef.comp)

#create df of OTU taxon and guild info matched with coef value
coef.comp.df %>% left_join(taxAndFunguild) -> coef.comp.ann

#classify samples into quantiles based on coef value
quant<-quantile(coef.comp.ann$coefComp, c(.05, .95))
coef.comp.ann$quant<-"middle"
coef.comp.ann[coef.comp.ann$coefComp > quant[2],'quant']<-"upper95"
coef.comp.ann[coef.comp.ann$coefComp < quant[1],'quant']<-"lower5"
plot.df<-subset(coef.comp.ann, quant != "middle") #get rid of the middle for plotting
unique(plot.df$kingdom)

```
By trophic mode -- note that one of the species' names has weird characters in it that makes the name dissapear in the ggplots (genus: Montagnula)
```{r, echo=FALSE, warnings=FALSE, message=FALSE}

#define cols
colvals<-rainbow_hcl(length(unique(coef.comp.ann$Trophic.Mode)))
names(colvals)<-unique(coef.comp.ann$Trophic.Mode)
colvals['unclassified']<-"#D3D3D3"

pTroph<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=Trophic.Mode)) + 
  geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
  xlab("Fungal species") + ylab("Component coefficient estimate") +
  scale_color_manual(name="Trophic mode", values=colvals) +
  theme_classic()
pTroph

#one of the species names has weird characters in it
plot.df[plot.df$genus=="Montagnula","species"]

totallower<-sum(plot.df$quant=="lower5")
totalupper<-sum(plot.df$quant=="upper95")

plot.df %>%
  group_by(Trophic.Mode, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(Trophic.Mode != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(Trophic.Mode, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Trophic mode")


```
By phylum
```{r, echo=FALSE, warnings=FALSE, message=FALSE}

# #define cols
# colvals<-rainbow_hcl(length(unique(coef.comp.ann$phylum)))
# names(colvals)<-unique(coef.comp.ann$phylum)
# colvals['unclassified']<-"#D3D3D3"
# 
# pPhylum<-ggplot(plot.df, aes(x=reorder(species,coefComp), y=coefComp, color=phylum)) + 
#   geom_point() + coord_flip() + facet_grid(~quant, scale="free") +
#   xlab("Fungal species") + ylab("Component coefficient estimate") +
#   scale_color_manual(name="Phylum", values=colvals) +
#   theme_classic()
# pPhylum

plot.df %>%
  group_by(phylum, quant) %>%
  summarize(numOTUs=length(coefComp),
            freqlower=numOTUs/totallower,
            frequpper=numOTUs/totalupper) %>%
  filter(phylum != "unclassified") -> tmp
tmp$freq<-tmp$freqlower 
tmp[tmp$quant=="upper95","freq"]<-tmp[tmp$quant=="upper95","frequpper"]

ggplot(tmp, aes(x=reorder(phylum, freq), y=freq*100)) + 
  geom_bar(stat="identity") + facet_grid(~quant) + coord_flip() +
  ylab("OTU frequency (%)") + xlab("Phylum")

```





##########################################

# Diversity (and diversity of specific clades) as a predictor  

**Note that the full community matrix was used for these analyses**

## *Hyp-a (stem-level)* Greater microbial diversity (richness, Shannon diversity, ... add phylogenetic diversity) will lead to less mass remaining esp. at early time steps because of the selection effect for fast decayers and complementarity among taxa for decay.  
Hyp-Alt: Greater microbial diversity will lead to more mass remaining because taxa will be allocating more of their resources to combat one another.

### Richness, Shannon's H

**????**


## *Hyp-b (stem-level)* Greater saprotroph and basidiomycete richness will lead to less mass remaining esp. at early time steps because the community does not need to wait for the arrival of key decayers to act on the wood substrate.  
Hyp-Alt: Greater saprotroph and basidiomycete richness will lead to more mass remaining because decayers will be allocating more of their resources to combat one another.

### Saprotroph richness, Basidio richness

**????**


## *Hyp-c (stem-level)* Greater pathogen and oomycete richness will lead to more mass remaining because the presence of these organisms will inhibit the establishment and activity of decayers.

### Pathogen richness, oomycete richness

**????**





##############################################

# Diversity plus traits as a predictor

## *Hyp (stem-level)* After accounting for variation in decay due to wood traits, initial microbial diversity (richness, Shannon diversity, ... add phylogenetic diversity) will predict variation in percent mass loss, esp. at early time points.

### Richness, Shannon's H, Saprotroph richness, Basidio richness, Pathogen richness, Oomycete richness

**?????**




##############################################

# Relationship between wood traits and community

## *Hyp (stem-level)* Initial microbial communitiy compositions will covary with initial wood traits

```{r, echo=FALSE}

# #get rid of missing data from traits.mean
# traits.mean %>%
#   filter(!is.na(waterperc)) %>% #get NaN row
#   filter(code %in% row.names(meanOTUabund.trim2)) -> traits.mean.trim #get rid of rows for which there is missing community data... this is eusc
# 
# #make sure dimensions of the community matrix match
# meanOTUabund.trim3<-meanOTUabund.trim2[row.names(meanOTUabund.trim2) %in% traits.mean.trim$code,]
# 
# #make a envVars matrix for model fitting
# envVars<-as.matrix(traits.mean.trim[,-(1:3)])
# 
# #fit models
# fit.cca <- cca(meanOTUabund.trim3 ~ envVars)
# #fit.cca
# #plot(fit.cca)
# #anova(fit.cca)


```



##############################################

## Extra pieces

1. *code/testing_time_zero.Rmd* -- Including t=0 points to fit decay model affects the liklihood and the model selection criteria, but the curve fits are identical with this formulation.  Excluding the t=0 fits has an effect of prefering simpler models, which is the same effect as increasing the penalty for model complexity. 

2. *code/initialDist_vs_decayDist_btwCode.Rmd* -- No apparent relationship between species+size dissimilarities in initial microbial community composition (bray and jaccard) and decay trajectory params

3. *code/boralOTUpairs_vs_decay.Rmd* -- No apparent relationship between frequency of boral-ID'd positively/negatively correlated OTU pairs and decay params

4. *code/withinInitialDist_vs_decayR2.Rmd* -- No apparent relationship between initial microbial diversity WITHIN species+size and decay model R2

5. *code/unexpectedTaxa.Rmd* -- Mycorrhizal fungi and animal-associated fungi that somehow made it into our OTU table

6. *code/code_level_analyses.Rmd* -- Aggregated data to the code level, taking trait means, community means, and estimating the fit params for each code's decay trajectory in neg.exp and weibold models...  

1. Traits explain ~ 60-70% of variation in decay over 37 months (r2, k, t70)  

  a. Greater water content and greater Zn and N leads to better-fitting decay models  
  
  b. Small size stems, greater water content, thinner bark, less Ca, more Zn, and more N lead to faster decay  
  
  c. Small stem sizes, less water content, thicker bark, more Ca, less Zn, and less N lead to longer wood “70%”-lives

2. Neither community components, overall diversity, nor clade-based diversity metrics are significant predictors of r2, k, t70  

3. After accounting for variation in decay due to wood traits, neither the community components, overall diversity, nor clade-based diversity metrics are significant predictors of r2, k, t70



